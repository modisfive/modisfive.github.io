{"componentChunkName":"component---src-templates-post-jsx","path":"/http-vs-https/","result":{"data":{"site":{"siteMetadata":{"title":"modisfive's 블로그"}},"markdownRemark":{"id":"e6377fd6-119b-5226-ac18-d30cbc8c91a8","excerpt":"HTTP와 HTTPS HTTP(Hyper Text Transfer Protocol)는 서버/클라이언트 모델에 따라 데이터를 주고 받기 위한 프로토콜입니다. 즉, HTTP는 인터넷에서 하이퍼 텍스트를 교환하기 위한 통신 규약으로, 80번 포트를 사용하고 있습니다. HTTP의 문제점 HTTP는 평문 통신이기 때문에 도청이 가능하다. 통신 상대를 확인하지 않기…","html":"<figure>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/8d88887225da1f9346d842abd1f7699d/59f54/http-vs-https-01.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 17.64705882352941%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA0UlEQVR42mXO207DMAwG4L7/W3GBhBAINAYsNMuho2mObZjUNm0vfoxAk9AuPsV27MQVe3woL2xXnl73hTFeuJREXRNUP4rCal7e3lk5sPoK+6iXSt/e4Jnf426/g7Me0TqE1iCYDvGPpzx6j9T3sM5BKgUhFeiDf45CopLU7GzA6dRC1BxZaGRjkdvuF8VnuhukRsoZMUaklBDJOI6YpulinmdUTaPho0fTfkJxji8azsOAHBOGENHTA+efU2l0tKUxBj4EBKoty4J1XS+2bcM37YQl9PCuLbUAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='http vs https 01' title='' src='/static/8d88887225da1f9346d842abd1f7699d/ca1dc/http-vs-https-01.png' srcset='/static/8d88887225da1f9346d842abd1f7699d/e7570/http-vs-https-01.png 170w,\n/static/8d88887225da1f9346d842abd1f7699d/f46e7/http-vs-https-01.png 340w,\n/static/8d88887225da1f9346d842abd1f7699d/ca1dc/http-vs-https-01.png 680w,\n/static/8d88887225da1f9346d842abd1f7699d/59f54/http-vs-https-01.png 792w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption>출처: https://www.cloudflare.com/ko-kr/learning/ssl/what-is-https/</figcaption>\n</figure>\n<h2>HTTP와 HTTPS</h2>\n<p>HTTP(Hyper Text Transfer Protocol)는 서버/클라이언트 모델에 따라 데이터를 주고 받기 위한 프로토콜입니다. 즉, HTTP는 인터넷에서 하이퍼 텍스트를 교환하기 위한 통신 규약으로, 80번 포트를 사용하고 있습니다.</p>\n<h3>HTTP의 문제점</h3>\n<ul>\n<li>HTTP는 평문 통신이기 때문에 도청이 가능하다.</li>\n<li>통신 상대를 확인하지 않기 때문에 위장이 가능하다.</li>\n<li>완전성(정확성)을 증명할 수 없기 때문에 조작이 가능하다.</li>\n</ul>\n<p>HTTPS(HTTP over SSL, HTTP over TLS, HTTP Secure)는 HTTP에 데이터 암호화가 추가된 프로토콜이고, HTTP와 달리 443번 포트를 사용합니다. HTTPS의 가장 큰 특징은 HTTP가 가지고 있던 보안 문제들을 해결한다는 것입니다. 즉, HTTPS는 <strong>암호화, 인증, 완전성 보장</strong>을 지원합니다.</p>\n<h2>SSL과 TLS</h2>\n<p>넷스스케이프가 SSL(Secure Socket Layer)을 발명하고, 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로 넘어가면서 TLS(Transport Layer Security)로 이름이 바뀌었습니다. TLS 1.0은 SSL 3.0을 계승합니다.<br>\n물론 TLS가 발전하면서 차이점도 존재하지만, 동작 방식은 유사하니 이 글에서는 같은 의미로 말합니다.</p>\n<h2>대칭키 암호화와 비대칭키 암호화</h2>\n<h3>대칭키 암호화</h3>\n<figure>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/735838ae354b376e7c746868b4cbcd3e/c0214/http-vs-https-02.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 54.70588235294118%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABxUlEQVR42m1SW27aUBD1ihoJiRWwGiQipb/pPyuABfSjQUL5hCZIreqKFqkQ2yIEFbCNMfhV2/Xj+hITfCE51GpSkd6vufM6Z84M9/jqua47mUxkWTZNY7lcapo2m83m8/l2u0V0v98/Z3Kvi9M0jaIoIcQPIu93SGkSBEGSJLvd7ijzuBjtUbx5OIA0P9+9b0swNpsHvCzL/lO8//tgB3Fyf5/m9q1sfR9qMIAZEZrQ9VHyCzIay7Ofl58k3YkO3222Wq0s22F/2HaHyyu+7/6y/x2bA0lIoigKIYSxzAsIoSkCnudBM1VRHcfBN6Ybx/WR4Pu+qqrQD3S4MAyRJIriYDDodDpf+S9xFFFKRUHo9Xr9/g9RlD5cXFxfX0F81/Vy5XmeR1MujuPxeGzbdqvVKhaLJ29Ozs7enlYqH9vt4fDWMIxGo1EoFEqlUrlcPn93/q3bXSx0gIMah62ANqzpdFqtVuv1umOjqSNJkiAIo9FocHNTq9WazSYWBkaABZJpmjiHw8y6rq8Mw/P9XIZcD8TACB1JTJ5FPmjhe7gcaLlerzksdqEtAI4PwtA8PwZMrioKaAMNfsZY7g/DAH7LshhjTz8OUAU2xg4+AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='http vs https 02' title='' src='/static/735838ae354b376e7c746868b4cbcd3e/ca1dc/http-vs-https-02.png' srcset='/static/735838ae354b376e7c746868b4cbcd3e/e7570/http-vs-https-02.png 170w,\n/static/735838ae354b376e7c746868b4cbcd3e/f46e7/http-vs-https-02.png 340w,\n/static/735838ae354b376e7c746868b4cbcd3e/ca1dc/http-vs-https-02.png 680w,\n/static/735838ae354b376e7c746868b4cbcd3e/c0214/http-vs-https-02.png 796w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption>출처: https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences</figcaption>\n</figure>\n<ul>\n<li>클라이언트와 서버가 동일한 키를 사용하여 암호화/복호화를 진행</li>\n<li>키가 노출되면 매우 위험하지만, 연산 속도가 빠름</li>\n</ul>\n<p>그런데, 이 대칭키를 어떻게 양쪽이 공유를 할까요? 대칭키가 중간에 갈취 당한다면 큰 문제일 것입니다. 이러한 대칭키 암호화 방식의 한계로, 비대칭키 암호화 방식이 등장했습니다.</p>\n<h3>비대칭키(공개키) 암호화</h3>\n<figure>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/a4c7c0fc6770b337f41a2b8aadcb6e08/c0214/http-vs-https-03.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 54.70588235294118%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABzElEQVR42m1Sy27aQBT1HyEh8QV8DVIqseoikbrkC+ATChKLSpFoGtiElgipAdtJEKoAUz+wsWsbZsbxS3js5CSpojTprO77nHvuCPfv3m63W61Wi8XC0I3tdquqv/GWy2UYhsgWRfFSKbxvTtOUUkYpcX3bdnePNiGMBYfD4U3l22ZUxHGcZTxJo/bg08fmqWHT+4JjYpZl/2ku/r4c9l3IkjSBkSTJ7Wrw5UL2SQQ3uIvCKH5VXPyDzHm2+LW8lE49asAFVU3XdN2gLIA7utYHP6buH/v12gIQVFVVFCUIGOc5CdwoZkh4vgfZEHccBy4JYuwPAN/31+s1JMzzXCCEoEiSpMlk0u/3hxffoRCElURxPB5fXf2UJPlzu31+/s2yTNd1ITs6h8MhhgqMsfl8btt2r9erVCqlUqler384Ojr72ru5uTVNs9PplMvlarVaq9WOT44vRyNN0wHueZ5AKQVtWDhso9FotVqOjaGOLMuiKM5ms8l02mw2u93ufr8HI8ACybIssHjcWdf1jWl6vv8sw7MeyIERJgZPgr0oDC0Mw9hsNlEUCTispmoAh4M0jgklUIRfslYU0AYa4hxiPsUJ2SOOn8c5fwAjjk3czwOjDQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='http vs https 03' title='' src='/static/a4c7c0fc6770b337f41a2b8aadcb6e08/ca1dc/http-vs-https-03.png' srcset='/static/a4c7c0fc6770b337f41a2b8aadcb6e08/e7570/http-vs-https-03.png 170w,\n/static/a4c7c0fc6770b337f41a2b8aadcb6e08/f46e7/http-vs-https-03.png 340w,\n/static/a4c7c0fc6770b337f41a2b8aadcb6e08/ca1dc/http-vs-https-03.png 680w,\n/static/a4c7c0fc6770b337f41a2b8aadcb6e08/c0214/http-vs-https-03.png 796w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption>출처: https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences</figcaption>\n</figure>\n<ul>\n<li>두 개의 키 중 하나로 암호화하면, 나머지 키로만 복호화가 가능\n<ul>\n<li>예를 들어 A 키와 B 키가 하나의 쌍이라면, A 키로 암호화를 하면 B 키로 복호화를 할 수 있고, B 키로 암호화를 하면 A 키로 복호화를 할 수 있다.</li>\n<li>둘 중 하나를 공개키라 하고, 다른 하나를 개인키로 정한다.</li>\n</ul>\n</li>\n<li>클라이언트는 공개키를 가지고, 서버는 개인키를 가짐\n<ul>\n<li>공개키는 이름에서 알 수 있다시피 누구나 가질 수 있다. 대신, 개인키는 서버만 가지고 있다.</li>\n</ul>\n</li>\n<li>키가 노출되더라도 비교적 안전하지만, 연산 속도가 느림</li>\n</ul>\n<p>우리가 네이버에서부터 정보를 받았을 때, 이게 진짜 네이버에서 왔는지 어떻게 알 수 있을까요?</p>\n<ol>\n<li>네이버에서 우리에게 보내는 정보들은 그 일부가 네이버의 개인키로 암호화가 되어있다.</li>\n<li>네이버의 개인키로 암호화된 정보를 복호화할 수 있는 것은 우리가 가진 네이버의 공개키 뿐이다.</li>\n<li><strong>만약 우리가 가진 네이버의 공개키로 온전히 복호화를 할 수 있다면, 그것은 네이버에서 온 정보일 것이다.</strong></li>\n</ol>\n<p>이 예시는 단순히 인증을 이해하기 위한 예시로, 비대칭키 암호화를 사용하면 이렇게 인증을 할 수 있다는 것만 확인합니다. 실제로 서버의 인증은 이후에 설명할 SSL 인증서를 통해 진행됩니다.</p>\n<h2>SSL 인증서</h2>\n<p>SSL 인증서는 클라이언트와 서버 간의 통신을 제3자가 보증해주는 전자화된 문서입니다. 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달합니다. 클라이언트는 이 인증서가 신뢰할만한 것인지 검증 후에 그 다음 절차를 진행합니다.</p>\n<p>이 SSL 인증서를 통해 위에서 언급한 HTTP의 보안 문제를 해결합니다. 즉, SSL 인증서의 기능은 크게 다음과 같습니다.</p>\n<ol>\n<li>클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장한다.</li>\n<li>SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.</li>\n</ol>\n<h3>CA(Certificate Authority)</h3>\n<p>앞서 말했듯, 인증서의 역할 중 하나는 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장하는 것입니다. 그럼 누가 보증을 해줄까요? 이를 인증하는 공인된 민간 기업들이 있습니다. 이러한 기업들을 CA라 합니다. SSL을 통해서 암호화된 통신을 제공하려는 서비스는 CA를 통해 인증서를 구입해야 합니다.</p>\n<h3>SSL 인증서의 내용</h3>\n<ul>\n<li><strong>서비스의 정보</strong> (인증서를 발급한 CA, 서비스의 도메인 등등)\n<ul>\n<li>클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지에 대한 내용</li>\n</ul>\n</li>\n<li><strong>서버 측의 공개키</strong> (공개키의 내용, 공개키의 암호화 방법)\n<ul>\n<li>서버와 통신할 때 사용할 공개키와 그 공개키의 암호화 방법</li>\n</ul>\n</li>\n</ul>\n<p>서비스의 도메인, 공개키와 같은 정보는 서비스가 CA로부터 인증서를 구입할 때 제출해야 합니다. 이 내용들은 CA에 의해서 암호화되는데, 이때 사용하는 암호화 방식이 공개키(비대칭키) 방식입니다. <strong>CA는 자신의 CA 개인키를 이용해서 서비스에서 제출한 인증서를 암호화하는 것입니다.</strong> CA의 개인키는 절대로 유출되어서는 안됩니다. 그리고, 우리가 사용하는 브라우저에는 CA들의 목록과 그들의 공개키가 내장되어 있습니다.</p>\n<h2>SSL 인증서가 서비스를 보증하는 방법</h2>\n<ol>\n<li>웹 브라우저가 서버에 접속할 때 서버는 제일 먼저 클라이언트에게 인증서를 제공한다.</li>\n<li>브라우저는 이 인증서를 발급한 CA가 자신이 내장한 CA의 리스트에 있는지를 확인한다.</li>\n<li>확인 결과 서버에서 받은 인증서가 내장된 CA 리스트에 포함되어 있다면, 해당 CA의 공개키를 이용해서 인증서를 복호화한다.</li>\n<li><strong>CA의 공개키를 이용해서 인증서를 복호화 할 수 있다는 것은 이 인증서가 CA의 개인키에 의해서 암호화 된 것을 의미한다.</strong></li>\n<li>해당 CA의 개인키를 가지고 있는 CA는 해당 CA 밖에는 없기 때문에, 서버가 제공한 인증서가 CA에 의해서 올바르게 발급된 것이라는 것을 의미한다.</li>\n<li>즉, CA에 의해서 발급된 인증서라는 것은 접속한 사이트가 CA에 의해서 검토되었다는 것을 의미하고, CA의 검토를 통과했다는 것은 해당 서비스가 신뢰 할 수 있다는 것을 의미한다.</li>\n</ol>\n<p>이렇게 해서 인증서가 서버의 신뢰성을 제공하는 방법을 알아봤습니다. 그런데 의문점이 남습니다. 인증서에 포함된 서버의 공개키는 어떤 용도에 사용될까요?</p>\n<h2>SSL의 동작 방법</h2>\n<p>비대칭키 암호화 방식만을 사용하면 컴퓨팅 파워가 많이 소모되기 때문에 SSL 인증서에서는 <strong>대칭키 방식과 비대칭키 방식 모두를 사용</strong>하고 있습니다. 클라이언트와 서버가 주고 받는 실제 정보는 대칭키 방식으로 암호화하고, 이 대칭키를 비대칭키 방식으로 암호화하여 클라이언트와 서버가 공유합니다.</p>\n<ul>\n<li><strong>실제 데이터 : 대칭키 방식</strong></li>\n<li><strong>대칭키 방식의 키 : 비대칭키 방식</strong></li>\n</ul>\n<p>컴퓨터와 컴퓨터가 네트워크를 통해 통신을 할 때 내부적으로 3단계를 거칩니다.</p>\n<blockquote>\n<p>Handshake → 전송 → 세션 종료</p>\n</blockquote>\n<p>이러한 과정에서 SSL이 어떻게 데이터를 암호화하여 전달하는지 알아봅시다.</p>\n<figure>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/b6c3265b63fd50ce949c3df89a6326d2/92fa7/http-vs-https-04.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 57.05882352941176%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB70lEQVR42lVRTW8TQQzd30q5c+APcAROHJA4wQFVIqUCwSkcAkpR06ZJ01aFhgbytd+zu2N7PLOz3aQtZUKERKwnz4w19rP9PP3PmLUQGMaZL6BQ2ugNi+I4SVO9GfbWaS6a56iwDDOb8EIa68LrH8boVOA0onGictKl2Ux279qWTJwEsD+IumOIyJT/sQAoP5STxJ1aMSte82lvYU1nkr84mL8+HD9rT1rffFFAKgmVAlKklGblqiOAVni3sDe1/X1V1tYws2eNnmR0OC36M3nkwyjMXFkglqTWyJBSoKyAwTTdOQ3en0wbJ/6xX9SV9VzD3Wn68uhno//jVW/cGfmEMgdwG3DIQAkg4e6FPJvLjxfY/J46fzyHJAo9Uy5F8GU4eHzWe355+mQ+bgESoSDM/iJXlBtGQDZZ7y7dXgS7t8l2lXfCSHhsrmo5uI4adfzhOt5RSZ/Ystseo1aFJsEkDIYgM+2/y7tbw88P4s69Onxj7I2n7a2Zvw2+bl22H4b794tfu0zSoK8xYpWzQgfNhOiaCCwMKxyWMMR8Np3NHXNlcWRFW8UHldiD9ALJLRhWoNzRMqYafZRCBU08f+T3nzpfRs0CVjo7zSo2S13WulwWcjWwm1NRtgZT4cjB6Zad2/gT+i0TNV0L2lR/ANh5UJE5gHSTAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='http vs https 04' title='' src='/static/b6c3265b63fd50ce949c3df89a6326d2/ca1dc/http-vs-https-04.png' srcset='/static/b6c3265b63fd50ce949c3df89a6326d2/e7570/http-vs-https-04.png 170w,\n/static/b6c3265b63fd50ce949c3df89a6326d2/f46e7/http-vs-https-04.png 340w,\n/static/b6c3265b63fd50ce949c3df89a6326d2/ca1dc/http-vs-https-04.png 680w,\n/static/b6c3265b63fd50ce949c3df89a6326d2/02d09/http-vs-https-04.png 1020w,\n/static/b6c3265b63fd50ce949c3df89a6326d2/9d567/http-vs-https-04.png 1360w,\n/static/b6c3265b63fd50ce949c3df89a6326d2/92fa7/http-vs-https-04.png 2918w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption>SSL Handshake는 TCP 레이어의 3-way Handshake 이후에 진행된다.</figcaption>\n</figure>\n<ol>\n<li><strong>SSL Handshake</strong>\n<ol>\n<li>Client Hello : 클라이언트가 서버에 접속한다. 그리고 클라이언트에서 서버에 다음과 같은 정보를 전달한다.\n<ul>\n<li>클라이언트에서 생성한 랜덤 데이터</li>\n<li>클라이언트가 지원하는 암호화 방식</li>\n<li>세션 아이디 : 이미 SSL Handshaking을 했다면 비용과 시간 절약을 위해 기존 세션을 재활용하는데 이를 위한 식별자(이 과정에서는 크게 중요하지 않다.)</li>\n</ul>\n</li>\n<li>Server Hello : 서버는 Client Hello에 대한 응답으로 Server Hello 과정을 거치고, 클라이언트에 다음과 같은 정보를 전달한다.\n<ul>\n<li>서버에서 생성한 랜덤 데이터</li>\n<li>서버가 지원하는 암호화 방식</li>\n<li>인증서</li>\n</ul>\n</li>\n<li>클라이언트는 서버에게서 받은 인증서가 CA가 발급한 것인지를 확인하기 위해 클라이언트에 내장된 CA 리스트를 확인한다.<br>\n만약, 그 리스트에 인증서가 없다면 사용자에게 경고 메시지를 출력한다. 인증서가 CA에 의해서 발급된 것인지 확인하기 위해 내장된 CA의 공개키로 복호화를 시도한다. 만약, 복호화에 성공하면 CA의 개인키로 암호화된 것이기 때문에 신뢰할 수 있다.<br>\n클라이언트는 자신이 생성한 랜덤 데이터와 서버에서 받은 랜덤 데이터를 조합하여 pre master secret이라는 키를 생성한다. 이 pre master secret이라는 키를 서버에도 전달해줘야 하는데, 이 때 <strong>공개키 방식</strong>으로 암호화를 한다.<br>\n복호화된 인증서 안에는 서버가 생성한 공개키가 들어있다고 했었다. 클라이언트는 성공적으로 인증서를 복호화하면 서버 측에서 만든 공개키를 획득하게 된다. 클라이언트는 인증서에서 얻는 서버의 공개키로 pre master secret 값을 암호화하고 서버에 전달한다.</li>\n<li>서버는 그 공개키에 대한 개인키를 가지고 있기 때문에 pre master secret 값을 얻어낼 수 있다. 이제 클라이언트와 서버 모두 pre master secret 값을 공유하게 되었다. 클라이언트와 서버는 각각 일련의 과정을 통해 pre master secret에서 master secret 값을 만들어내고, 이 master secret으로 세션키를 생성한다. 이 세션키를 이용해서 서버와 클라이언트는 실제 데이터를 <strong>대칭키 방식</strong>으로 암호화하여 주고 받는다.</li>\n</ol>\n</li>\n<li><strong>전송(세션)</strong><br>\n실제로 클라이언트와 서버가 데이터를 주고 받는 단계이다. 이전 단계에서 얻은 세션키를 이용하여 대칭키 방식으로 데이터를 암호화하고 상대방에게 전달한다.</li>\n<li><strong>세션 종료</strong><br>\n데이터 전송이 끝나면 서로에게 SSL 통신이 끝났음을 알린다. 이 때 통신에서 사용한 대칭키인 세션키를 폐기한다.</li>\n</ol>\n<h2>참고 자료</h2>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=H6lpFRpyl14\">https://www.youtube.com/watch?v=H6lpFRpyl14</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=0cfUVrQW_yg&#x26;list=PLCZ-8rvakaqbplQZAoUku8uuxUgbLQm-1\">https://www.youtube.com/watch?v=0cfUVrQW_yg&#x26;list=PLCZ-8rvakaqbplQZAoUku8uuxUgbLQm-1</a></li>\n<li><a href=\"https://opentutorials.org/course/228/4894\">https://opentutorials.org/course/228/4894</a></li>\n<li><a href=\"https://ko.gadget-info.com/difference-between-ssl\">https://ko.gadget-info.com/difference-between-ssl</a></li>\n</ul>","frontmatter":{"title":"[Network] HTTP와 HTTPS","date":"March 26, 2024","tags":["HTTP","HTTPS","Network","네트워크","공개키","대칭키","비대칭키","SSL"],"series":"네트워크/Network"},"fields":{"slug":"/http-vs-https/"}},"seriesList":{"edges":[{"node":{"id":"e6377fd6-119b-5226-ac18-d30cbc8c91a8","fields":{"slug":"/http-vs-https/"},"frontmatter":{"title":"[Network] HTTP와 HTTPS"}}}]},"previous":{"fields":{"slug":"/whiletrue-review/"},"frontmatter":{"title":"whileTrue 프로젝트 후기"}},"next":{"fields":{"slug":"/aws-alb-502/"},"frontmatter":{"title":"AWS ALB가 502를 내뱉는다"}}},"pageContext":{"id":"e6377fd6-119b-5226-ac18-d30cbc8c91a8","series":"네트워크/Network","previousPostId":"938c4a2f-4994-5be8-8675-8e8f1ec33af1","nextPostId":"dcdd86c3-0d41-503b-b005-fc8344a6ad53"}},"staticQueryHashes":[],"slicesMap":{}}