{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"문제 발생 whileTrue 서비스를 쓰고 있는데 어느 순간부터 크롬 확장 프로그램이 제대로 동작하지 않았습니다. 콘솔을 보니 다음과 같은 에러 메시지가 출력되고 있었습니다. 에러 메시지를 자세히 보니 반환된 메시지를 JSON으로 변환하려다가 문제가 생긴 것 같았습니다. 여기서 \"아! JSON 객체가 넘어온 것이 아니구나!\"를 깨닳았습니다. 그래서 백엔드…","fields":{"slug":"/aws-alb-502/"},"frontmatter":{"date":"April 12, 2024","title":"AWS ALB가 502를 내뱉는다","tags":["whileTrue","ConnectionTimeout","keep-alive","AWS","ALB","502"]},"rawMarkdownBody":"\n## 문제 발생\n\nwhileTrue 서비스를 쓰고 있는데 어느 순간부터 크롬 확장 프로그램이 제대로 동작하지 않았습니다. 콘솔을 보니 다음과 같은 에러 메시지가 출력되고 있었습니다.\n\n<figure>\n    <img src=\"img/aws-alb-502-01.png\">\n</figure>\n\n에러 메시지를 자세히 보니 반환된 메시지를 JSON으로 변환하려다가 문제가 생긴 것 같았습니다. 여기서 \"아! JSON 객체가 넘어온 것이 아니구나!\"를 깨닳았습니다. 그래서 백엔드에서 반환된 메시지를 그냥 출력시켜봤는데..\n\n<figure>\n    <img src=\"img/aws-alb-502-02.png\">\n</figure>\n\n이렇게 502 Bad Gateway를 반환하고 있었습니다.\n\n음.. 당연히 비즈니스 로직 상의 Spring Boot 서버가 502를 반환할 리는 없고.. 그렇다고 EC2에서 반환할 리가 없을 것 같은데.. 다른 인프라가 있나? 라고 생각한 순간 머리 속을 스쳐간 것이 AWS의 ALB입니다. 이전에 도메인을 연결하면서 ALB를 설정했었는데 거기서 잘못됐나보다라고 생각하게 됐습니다.\n\nAWS에서 ALB 모니터링을 보니 502를 반환하고 있던 것을 확인했습니다.\n\n<figure>\n    <img src=\"img/aws-alb-502-03.png\">\n    <figcaption>ALB 모니터링</figcaption>\n</figure>\n\n## 문제 알아보기\n\n구글에 AWS ALB가 502를 반환하는 경우를 검색해보았는데, 꽤나 많은 자료들이 있었습니다.\n\n우선, ALB의 로그를 확인해보기로 했습니다. 로그 확인 방법은 아래의 블로그를 참고하여 진행했습니다.\n\n- https://docs.aws.amazon.com/ko_kr/athena/latest/ug/application-load-balancer-logs.html\n- https://inpa.tistory.com/entry/AWS-%F0%9F%93%9A-ELBALB-%EB%A1%9C%EA%B7%B8-%ED%99%9C%EC%84%B1%ED%99%94-S3%EC%97%90-%EB%A1%9C%EA%B7%B8-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0\n- https://velog.io/@jiyeon_hong/AWS-Athena%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-ALB-Access-Log-%EB%B6%84%EC%84%9D-%EB%B0%A9%EB%B2%95\n- https://metaverse-cloud.tistory.com/264\n\n생성된 로그에서 status code가 502인 경우들을 모두 검색했습니다.\n\n<figure>\n    <img src=\"img/aws-alb-502-04.png\">\n    <figcaption>status_code가 502인 경우 검색</figcaption>\n</figure>\n\n<figure>\n    <img src=\"img/aws-alb-502-05.png\">\n    <figcaption>검색 결과</figcaption>\n</figure>\n\n여기서 request_processing_time, target_processing_time, response_processing_time 모두 -1인 것을 확인할 수 있습니다. AWS 문서에서는 이 경우에 대한 원인을 알려주고 있었습니다.\n\n<figure>\n    <img src=\"img/aws-alb-502-06.png\">\n    <figcaption>출처: https://repost.aws/ko/knowledge-center/elb-alb-troubleshoot-502-errors</figcaption>\n</figure>\n\n<figure>\n    <img src=\"img/aws-alb-502-07.png\">\n    <figcaption>영문이 좀 더 명시적으로 해결해주는 듯하다.</figcaption>\n</figure>\n\n\"_대상의 연결 유지 제한 시간이 로드 밸런서의 유휴 제한 시간보다 짧을 때 발생합니다._\"라고 나와 있습니다.\n\n### HTTP 502 상태 코드란?\n\nRFC 7231 문서에서는 다음과 같이 설명하고 있습니다.\n\n<figure>\n    <img src=\"img/aws-alb-502-08.png\">\n    <figcaption>출처: https://datatracker.ietf.org/doc/html/rfc7231#section-6.6.3</figcaption>\n</figure>\n\n게이트웨이나 프록시 서버에서 백엔드 서버로 응답을 요청했는데, 유효하지 않은 응답을 받은 경우 반환한다고 합니다. 우리 같은 경우는 ALB에서 Spring 서버로 요청을 했는데, Spring 서버에서 유효하지 않은 응답을 보내온 경우로 볼 수 있습니다.\n\n### keep-alive?\n\n<figure>\n    <img src=\"img/aws-alb-502-09.svg\">\n    <figcaption>출처: https://ko.wikipedia.org/wiki/HTTP_%EC%A7%80%EC%86%8D%EC%A0%81_%EC%97%B0%EA%B2%B0_%EC%83%81%ED%83%9C</figcaption>\n</figure>\n\nHTTP 통신을 시작할 때 TCP의 3-way handshake를 진행합니다. HTTP 통신을 마무리할 때에는 4-way handshake를 진행합니다. 한 번의 HTTP 통신을 할 때마다 이 두 과정을 진행한다면 큰 overhead가 될 것입니다.\n\n이런 낭비를 방지하기 위해 한 번 TCP Connection을 맺으면 여러 번 데이터를 주고 받게 할 수 있습니다. 이것이 HTTP Keep-Alive입니다.\n\n(참고) http/1.0에서는 이 기능을 사용하기 위해서는 HTTP Header에 해당 설정을 명시해주어야 했지만, http/1.1부터는 굳이 명시하지 않아도 connection을 유지합니다.(기본으로 keep-alive가 설정되어있습니다.)\n\n### connectionTimeout vs. keepAliveTimeout\n\n- connectionTimeout : Client와 Server 간에 연결하는데 소요되는 최대 시간을 의미합니다. 즉, TCP 3-way handshake로 연결이 완료되기까지의 최대 시간이라 할 수 있습니다. 만약, 설정된 시간 내에 연결이 되지 않으면 timeout이 발생하게 됩니다.\n- keepAliveTimeout : 통신 없이 IDLE 상태로 연결을 유지하는 시간으로, 다른 요청을 받기까지 기다리는 최대 시간을 의미합니다. 가장 최근에 받은 요청에서 설정된 시간 내에 다른 요청을 받지 않으면 연결을 끊게 됩니다.\n\n### 그럼 왜 발생했을까?\n\n<figure>\n    <img src=\"img/aws-alb-502-10.webp\">\n    <figcaption>출처: https://www.tessian.com/blog/how-to-fix-http-502-errors/</figcaption>\n</figure>\n\nAWS 문서에도 나왔다시피 Server에서 먼저 connection을 닫아버려서 그렇습니다. ALB에서는 아직 보낼 데이터가 있는데 Server에서 HTTP 연결을 마무리하는 FIN을 보내고 연결을 끝냈습니다. 닫힌 소켓에 대해 응답을 받을 수 없으니 Client에게는 502 상태 코드를 보내게 됩니다.\n\n### request_processing_time, target_processing_time, response_processing_time\n\n<figure>\n    <img src=\"img/aws-alb-502-11.png\">\n    <figcaption>출처: https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/classic/access-log-collection.html#access-log-entry-format</figcaption>\n</figure>\n\n- request_processing_time : ALB가 클라이언트에게서 요청을 받고, 연결된 인스턴스(EC2)에 요청하기까지 걸린 시간\n  -1인 경우는 연결된 인스턴스가 유휴 시간 초과 이전에 연결을 닫은 경우일 수 있다고 합니다.\n- target_processing_time : ALB가 연결된 인스턴스에 요청을 하고, 응답을 받기까지 걸린 시간\n  -1인 경우는 역시 연결된 인스턴스가 유휴 시간 초과 이전에 연결을 닫은 경우일 수 있다고 합니다.\n- response_processing_time : ALB가 연결된 인스턴스에게 응답을 받고, 클라이언트에게 응답하기까지 걸린 시간\n  -1인 경우는 역시역시 연결된 인스턴스가 유휴 시간 초과 이전에 연결을 닫은 경우일 수 있다고 합니다.\n\n## 문제 해결하기\n\n<figure>\n    <img src=\"img/aws-alb-502-12.png\">\n    <figcaption>Connection idle timeout : 60초</figcaption>\n</figure>\n\nALB의 유휴 제한 시간은 60초입니다.\n\n<figure>\n    <img src=\"img/aws-alb-502-13.png\">\n    <figcaption>기본값은 connectionTimeout 값과 같다.</figcaption>\n</figure>\n\n<figure>\n    <img src=\"img/aws-alb-502-14.png\">\n    <figcaption>connectionTimeout의 기본값은 20초이다.</figcaption>\n</figure>\n\n이에 반해 Spring Boot의 연결 유지 제한 시간은 20초입니다.\n\nSpring Boot의 keep-alive-timeout을 70초(70000ms)로 늘려 최종적으로 해결했습니다.\n\n<figure>\n    <img src=\"img/aws-alb-502-15.png\">\n    <figcaption>application.yml에 다음과 같이 설정한다.</figcaption>\n</figure>\n\n## 참고\n\n- https://velog.io/@haron/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-AWS-ALB%EC%9D%98-HTTP-502-%EC%98%A4%EB%A5%98%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%B4%EB%B3%B4%EC%9E%90-dba4dfrv\n- https://inpa.tistory.com/entry/AWS-%F0%9F%93%9A-ELBALB-%EB%A1%9C%EA%B7%B8-%ED%99%9C%EC%84%B1%ED%99%94-S3%EC%97%90-%EB%A1%9C%EA%B7%B8-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0\n- https://docs.aws.amazon.com/ko_kr/athena/latest/ug/application-load-balancer-logs.html\n- https://docs.aws.amazon.com/elasticloadbalancing/latest/application/enable-access-logging.html\n- https://repost.aws/ko/knowledge-center/elb-alb-troubleshoot-502-errors\n- https://velog.io/@jiyeon_hong/AWS-Athena%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-ALB-Access-Log-%EB%B6%84%EC%84%9D-%EB%B0%A9%EB%B2%95\n- https://devocean.sk.com/blog/techBoardDetail.do?ID=165428&boardType=techBlog\n- https://metaverse-cloud.tistory.com/264\n- https://tomcat.apache.org/tomcat-8.5-doc/config/http.html\n- https://velog.io/@haron/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-AWS-ALB%EC%9D%98-HTTP-502-%EC%98%A4%EB%A5%98%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%B4%EB%B3%B4%EC%9E%90-dba4dfrv\n- https://www.tessian.com/blog/how-to-fix-http-502-errors/\n- https://goodgid.github.io/HTTP-Keep-Alive/\n"},{"excerpt":"☘️ 문제 https://www.acmicpc.net/problem/2283 ☘️ 풀이 한 점에 그 점을 포함하는 구간이 몇 개나 있는지를 확인하는 것이 중요합니다. 예를 들어, 2인 점을 포함하는 구간이 3개가 있다고 해보겠습니다. 정답이 되는 구간이 2를 포함하고 있지 않다가 2를 포함하게 되면, 구간에 포함된 길이의 합은 2를 포함하는 구간의 갯수인 3…","fields":{"slug":"/boj-2283/"},"frontmatter":{"date":"April 08, 2024","title":"[백준/BOJ] 2283. 구간 자르기 (파이썬)","tags":["PS","BOJ","백준","Python","투포인터","누적합"]},"rawMarkdownBody":"\n## ☘️ 문제\n\nhttps://www.acmicpc.net/problem/2283\n\n## ☘️ 풀이\n\n한 점에 그 점을 포함하는 구간이 몇 개나 있는지를 확인하는 것이 중요합니다. 예를 들어, 2인 점을 포함하는 구간이 3개가 있다고 해보겠습니다. 정답이 되는 구간이 2를 포함하고 있지 않다가 2를 포함하게 되면, 구간에 포함된 길이의 합은 2를 포함하는 구간의 갯수인 3만큼 증가하게 됩니다. 반대로 2를 포함하지 않게 된다면, 3만큼 감소하게 됩니다.\n\n정답이 되는 구간 [a, b]에 포함된 길이의 총합은 누적합을 이용해 구합니다. 구간 [0, a]에 포함된 길이의 총합에서 구간 [0, a + 1]에 포함된 길이의 총합을 구할 때 필요한 것은 `a + 1`인 점을 포함하는 구간이 몇 개가 있느냐 입니다. 그럼 그 갯수만큼 늘어나게 됩니다.\n\n`counts` 배열을 선언하여 입력받는 구간이 언제 시작하고 언제 끝나는지 저장합니다. 시작점은 구간의 갯수를 하나 늘어나는 것이기 때문에 +1을 하고 끝점은 갯수가 줄어드는 것이기 때문에 -1을 합니다. 순회하면서 `currCount`에 계속 더해주면 `currCount`는 현재 점을 포함하는 구간의 갯수를 가지게 됩니다. 그리고 `currCount` 값을 이용해서 0부터 지금까지의 길이의 총합을 누적합으로 구합니다.\n\n이후는 단순한 투포인터입니다. 누적합으로 구해진 `accSum`을 이용해서 현재 구간에 포함된 길이의 총합을 구합니다. 만약, 현재 길이의 총합이 `k`보다 부족하다면 `right`를 하나 늘려 구간을 더 포함시켜 봅니다. 반대로 현재 길이의 총합이 `k`보다 크다면 `left`를 하나 늘려 구간을 좁힙니다.\n\n## ☘️ 전체 코드 (파이썬)\n\n```python\nimport sys\n\ninput = sys.stdin.readline\n\n\nn, k = map(int, input().split())\naccSum = [0] * 1000002\ncounts = [0] * 1000002\nMAX = -1\n\nfor _ in range(n):\n    start, end = map(int, input().split())\n    counts[start] += 1\n    counts[end] -= 1\n    MAX = max(MAX, end)\n\ncurrCount = counts[0]\nfor i in range(1, 1000002):\n    accSum[i] = accSum[i - 1] + currCount\n    currCount += counts[i]\n\nleft, right = 0, 0\nwhile left < MAX + 1 and right < MAX + 1:\n    s = accSum[right] - accSum[left]\n    if s == k:\n        break\n    elif s < k:\n        right += 1\n    else:\n        left += 1\n\nif s == k:\n    print(left, right)\nelse:\n    print(0, 0)\n```\n"},{"excerpt":"☘️ 문제 https://www.acmicpc.net/problem/2293 ☘️ 풀이 주어진 동전으로 원하는 금액을 만드는 방법을 구하는 문제는 대표적인 dp 문제입니다. 하지만 이 문제에서 한 가지 조건이 있는데, 사용하는 동전의 구성은 같고 순서만 다른 경우는 모두 같은 경우라는 것입니다. 예를 들어, 사용할 수 있는 동전이 1원과 2원이 있다고 해보겠…","fields":{"slug":"/boj-2293/"},"frontmatter":{"date":"April 04, 2024","title":"[백준/BOJ] 2293. 동전 1 (파이썬)","tags":["PS","BOJ","백준","Python","다이나믹프로그래밍"]},"rawMarkdownBody":"\n## ☘️ 문제\n\nhttps://www.acmicpc.net/problem/2293\n\n## ☘️ 풀이\n\n주어진 동전으로 원하는 금액을 만드는 방법을 구하는 문제는 대표적인 dp 문제입니다. 하지만 이 문제에서 한 가지 조건이 있는데, 사용하는 동전의 구성은 같고 순서만 다른 경우는 모두 같은 경우라는 것입니다.\n\n예를 들어, 사용할 수 있는 동전이 1원과 2원이 있다고 해보겠습니다.\n\n<figure>\n    <img src=\"img/boj-2293-01.png\">\n</figure>\n\n여기서 같은 색으로 표시된 부분은 모두 중복되는 부분들입니다. 이 문제에서는 이런 부분들을 모두 한 가지의 경우로 보아야 합니다.\n\n한 번 사용한 동전은 다시 사용하지 않는 방법으로 중복을 피할 수 있습니다. 이전 금액에서 1원을 추가해 3원을 만들었으면, 나중에 또다시 1원을 추가해 3원을 만들면 안됩니다.\n\n<figure>\n    <img src=\"img/boj-2293-02.png\">\n</figure>\n\n1원짜리 동전을 추가해서 3원을 만들고, 2원짜리 동전을 추가해서 3원을 만든 다음에 다시 1원짜리 동전을 추가해서 3원을 만들면 안된다는 것입니다. 위 그림에서 빨간색으로 표시된 부분들이 다시 1원짜리 동전을 추가해서 3원, 4원을 만든 경우들입니다.(제외되어야 할 경우들입니다.)\n\n그리고 2원짜리 동전을 추가해서 금액을 만드는 경우에는 1원짜리를 사용해서 만든 경우에 추가할 수 있습니다. 즉, 이전에 사용한 동전들로 만든 경우의 수를 활용하면 됩니다.\n\n이렇게 구현하기 위해서 동전들을 순회하며 금액을 만들 수 있는 방법들을 구하면 됩니다.\n\n## ☘️ 전체 코드 (파이썬)\n\n```python\nimport sys\n\ninput = sys.stdin.readline\n\n\nn, k = map(int, input().split())\ncoins = [int(input()) for _ in range(n)]\ndp = [0] * (k + 1)\ndp[0] = 1\n\nfor c in coins:\n    for i in range(c, k + 1):\n        dp[i] += dp[i - c]\n\nprint(dp[k])\n```\n"},{"excerpt":"☘️ 문제 https://school.programmers.co.kr/learn/courses/30/lessons/67259 ☘️ 풀이 그냥 직진으로 이동하느냐, 90도로 꺾고 이동하느냐에 따라 더해지는 비용이 다릅니다. 따라서 현재 위치까지 올 수 있는 최소 비용을 방향에 따라 각각 따로 저장해야 합니다. 보통의 BFS 문제에서는 단순히 현재 위치까지 올 …","fields":{"slug":"/programmers-67259/"},"frontmatter":{"date":"April 03, 2024","title":"[프로그래머스] 67259. 경주로 건설 (파이썬)","tags":["PS","프로그래머스","Python","BFS"]},"rawMarkdownBody":"\n## ☘️ 문제\n\nhttps://school.programmers.co.kr/learn/courses/30/lessons/67259\n\n## ☘️ 풀이\n\n그냥 직진으로 이동하느냐, 90도로 꺾고 이동하느냐에 따라 더해지는 비용이 다릅니다. 따라서 현재 위치까지 올 수 있는 최소 비용을 방향에 따라 각각 따로 저장해야 합니다.\n\n보통의 BFS 문제에서는 단순히 현재 위치까지 올 수 있는 최소 비용을 저장하는데, 이 문제에서는 움직이는 방향에 따라 비용이 달라지기 때문에 예외 상황이 발생합니다.\n\n## ☘️ 전체 코드 (파이썬)\n\n```python\nfrom collections import deque\n\ndy = (0, 1, 0, -1)\ndx = (1, 0, -1, 0)\n\nINF = float(\"inf\")\n\n\ndef getCost(visited, y, x, prevDir, currDir):\n    if prevDir == -1:\n        return 100\n    elif prevDir == currDir:\n        return visited[y][x][prevDir] + 100\n    else:\n        return visited[y][x][prevDir] + 600\n\n\ndef solution(board):\n    n = len(board)\n\n    visited = [[[INF] * 4 for _ in range(n)] for _ in range(n)]\n    visited[0][0] = [0] * 4\n    que = deque()\n    que.append((0, 0, -1))\n    answer = INF\n\n    while que:\n        y, x, prevDir = que.popleft()\n\n        if (y, x) == (n - 1, n - 1):\n            answer = min(answer, visited[n - 1][n - 1][prevDir])\n            continue\n\n        for i in range(4):\n            ny = y + dy[i]\n            nx = x + dx[i]\n            cost = getCost(visited, y, x, prevDir, i)\n            if 0 <= ny < n and 0 <= nx < n and board[ny][nx] == 0 and cost < visited[ny][nx][i]:\n                visited[ny][nx][i] = cost\n                que.append((ny, nx, i))\n\n    return answer\n```\n"},{"excerpt":"☘️ 문제 https://www.acmicpc.net/problem/3020 ☘️ 풀이 높이가 n인 장애물은 1~n 사이의 높이로 날아가는 경우에도 모두 부딪히게 됩니다. 예를 들어, 높이가 4인 장애물은 높이 1로 날라가도, 높이 2로 날라가도, 높이 3으로 날라가도, 높이 4로 날라가도 모두 부딪힙니다. 이를 이용해서 우선 각 높이들의 갯수을 모두 입력 …","fields":{"slug":"/boj-3020/"},"frontmatter":{"date":"April 03, 2024","title":"[백준/BOJ] 3020. 개똥벌레 (파이썬/자바)","tags":["PS","BOJ","백준","Python","Java","누적합"]},"rawMarkdownBody":"\n## ☘️ 문제\n\nhttps://www.acmicpc.net/problem/3020\n\n## ☘️ 풀이\n\n높이가 n인 장애물은 1~n 사이의 높이로 날아가는 경우에도 모두 부딪히게 됩니다. 예를 들어, 높이가 4인 장애물은 높이 1로 날라가도, 높이 2로 날라가도, 높이 3으로 날라가도, 높이 4로 날라가도 모두 부딪힙니다. 이를 이용해서 우선 각 높이들의 갯수을 모두 입력 받은 다음, 각 장애물의 높이보다 낲은 높이에도 모두 갯수를 표시합니다.\n\n배열에 각 높이의 갯수를 저장합니다. 입력되는 높이들의 갯수를 저장합니다. 이후, 높이의 역순(4→3→2→1)으로 누적합을 진행합니다. 석순과 종유석은 기준점이 다를 뿐이기 때문에, 우선 각각 똑같이 진행한 후, 나중에 높이의 기준점만 맞춰주면 됩니다.\n\n이제 각 높이를 순회하면서 부딪히는 장애물의 갯수를 세어주면 됩니다. 석순(`bottom`)의 높이가 `height`인 경우, 종유석(`top`)의 높이는 `h - height + 1`입니다.\n\n## ☘️ 전체 코드 (파이썬)\n\n```python\nimport sys\n\ninput = sys.stdin.readline\n\nINF = float(\"inf\")\n\n\nn, h = map(int, input().split())\n\nbottom = [0] * (h + 1)\ntop = [0] * (h + 1)\n\nfor i in range(n):\n    _h = int(input())\n    if i % 2 == 0:\n        bottom[_h] += 1\n    else:\n        top[_h] += 1\n\nfor i in range(h, 1, -1):\n    bottom[i - 1] += bottom[i]\n    top[i - 1] += top[i]\n\nanswer = INF\ncount = 0\n\nfor height in range(1, h + 1):\n    cnt = bottom[height] + top[h - height + 1]\n\n    if cnt < answer:\n        answer = cnt\n        count = 1\n    elif answer == cnt:\n        count += 1\n\nprint(answer, count)\n```\n\n## ☘️ 전체 코드 (자바)\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static int n, h;\n    static int[] bottom, top;\n    static int answer, count;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb = new StringBuilder();\n\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        n = Integer.parseInt(st.nextToken());\n        h = Integer.parseInt(st.nextToken());\n\n        bottom = new int[h + 1];\n        top = new int[h + 1];\n        for (int i = 0; i < n; i++) {\n            int height = Integer.parseInt(br.readLine());\n            if (i % 2 == 0) {\n                bottom[height] += 1;\n            } else {\n                top[height] += 1;\n            }\n        }\n\n        for (int i = h; i > 1; i--) {\n            bottom[i - 1] += bottom[i];\n            top[i - 1] += top[i];\n        }\n\n        answer = Integer.MAX_VALUE;\n        count = 0;\n        for (int height = 1; height < h + 1; height++) {\n            int breakCount = bottom[height] + top[h - height + 1];\n\n            if (breakCount < answer) {\n                answer = breakCount;\n                count = 1;\n            } else if (breakCount == answer) {\n                count += 1;\n            }\n        }\n\n        sb.append(answer).append(\" \").append(count);\n        System.out.println(sb);\n    }\n}\n```\n"},{"excerpt":"☘️ 문제 https://www.acmicpc.net/problem/2560 ☘️ 풀이 짚신벌레는 태어난지 날이 지나고 날이 될 때까지 개체를 만들어낼 수 있습니다. 반대로 날짜 기준으로 한다면, 현재 날짜를 라고 할 때 일부터 일 사이에 있는 짚신벌레들이 개체를 만들어낼 수 있습니다. 즉, 일부터 일 사이에 있는 짚신벌레의 수만큼 늘어나게 됩니다. 같은 조…","fields":{"slug":"/boj-2560/"},"frontmatter":{"date":"April 03, 2024","title":"[백준/BOJ] 2560. 짚신벌레 (파이썬)","tags":["PS","BOJ","백준","Python","누적합","다이나믹프로그래밍"]},"rawMarkdownBody":"\n## ☘️ 문제\n\nhttps://www.acmicpc.net/problem/2560\n\n## ☘️ 풀이\n\n짚신벌레는 태어난지 `a`날이 지나고 `b`날이 될 때까지 개체를 만들어낼 수 있습니다. 반대로 날짜 기준으로 한다면, 현재 날짜를 `day`라고 할 때 `day - b`일부터 `day - a`일 사이에 있는 짚신벌레들이 개체를 만들어낼 수 있습니다. 즉, `day - b`일부터 `day - a`일 사이에 있는 짚신벌레의 수만큼 늘어나게 됩니다.\n\n<figure>\n    <img src=\"img/boj-2560-01.png\">\n</figure>\n\n같은 조건이 반복되고, 이전의 값이 계속 사용되어 저장해야 한다는 점에서 dp를 생각해볼 수 있습니다. 이때 저장되는 dp 값은 다음과 같이 정의할 수 있습니다. 단, 이때는 죽는 짚신벌레는 고려하지 않습니다. (이유는 아래에서 설명합니다.)\n\n> dp[day] : 0일부터 `day`일**까지** 생존하는 짚신벌레의 수\n\ndp에 저장되는 값이 누적합의 형태이기 때문에, `day - b`일부터 `day - a`일 사이에 있는 짚신벌레의 수는 `dp[day - a] - dp[day - b]`와 같습니다. 따라서, 점화식을 다음과 같이 세울 수 있습니다.\n\n```\ndp[day] = dp[day - 1] + dp[day - a] - dp[day - b]\n```\n\n이와 비슷한 논리로 짚신벌레는 태어난지 `d`일째에 죽는다는 것은 0일부터 `d`일까지 생존한다는 것입니다. 반대로 현재 날짜 `day`에 살아있는 짚신벌레의 수는 `day - d`일과 현재인 `day`일 사이에 있는 짚신벌레의 수입니다.\n\n<figure>\n    <img src=\"img/boj-2560-02.png\">\n</figure>\n\n추가 1) 코드 구현 시 뺄셈을 할 때, 음수값이 발생할 수 있기 때문에 나누는 수(1000)으로 한 번 더 해줍니다.\n\n추가 2) `day`를 하나씩 늘리며 하루하루 진행할 때, 죽는 짚신벌레의 수를 빼주지 않아도 됩니다. 어차피 b < d이기 때문에, 태어난 지 `d`일이 지난 짚신벌레는 번식을 하지 못해 짚신벌레의 수를 늘리는데 영향을 주지 않습니다.\n\n<figure>\n    <img src=\"img/boj-2560-03.png\">\n</figure>\n\n8일째에 생존하는 짚신벌레의 수를 구할 때, 우선 죽는 것을 고려하지 않고 개체수를 늘립니다. 그리고 태어난 지 6일이 지난 짚신벌레 즉, 2일(8-6)에 살아있는 짚신벌레의 수만큼 빼주면 됩니다.\n\n위에서 dp의 정의를 0일부터 현재까지 살아있는 짚신벌레의 수로 정했습니다. 죽은 짚신벌레를 빼기 위해 다음과 같이 코드를 짜게 된다면 중복으로 빠지는 짚신벌레가 발생하게 됩니다.\n\n```python\nfor day in range(1, n + 1):\n    dp[day] = dp[day - 1]\n    if a <= day:\n        dp[day] = (dp[day] + dp[day - a]) % DIV\n    if b <= day:\n        dp[day] = (dp[day] - dp[day - b] + DIV) % DIV\n    if d <= day:\n        dp[day] = (dp[day] - dp[day - d] + DIV) % DIV # 이미 빠진 개체도 또 빠지게 됩니다. (dp의 값이 누적합이기 때문에)\n```\n\n어차피 죽는 개체는 이미 번식을 하지 못하기 때문에, 먼저 죽는 것을 고려하지 않고 짚신벌레의 수를 구한 이후에 한 번에 죽는 개체수를 빼주면 됩니다.\n\n## ☘️ 전체 코드 (파이썬)\n\n```python\nimport sys\n\ninput = sys.stdin.readline\n\nDIV = 1000\n\n\na, b, d, n = map(int, input().split())\ndp = [0] * (n + 1)\ndp[0] = 1\n\nfor day in range(1, n + 1):\n    dp[day] = dp[day - 1]\n    if a <= day:\n        dp[day] = (dp[day] + dp[day - a]) % DIV\n    if b <= day:\n        dp[day] = (dp[day] - dp[day - b] + DIV) % DIV\n\nanswer = dp[n]\nif d <= n:\n    answer = (answer - dp[n - d] + DIV) % DIV\n\nprint(answer)\n```\n"},{"excerpt":"☘️ 문제 https://www.acmicpc.net/problem/1365 ☘️ 풀이 대표적인 LIS(최장 증가 부분 수열) 문제입니다. 전깃줄이 꼬여있지 않기 위해서는 오른편에서 연결된 전봇대 번호가 순서대로 증가해야 합니다. 예를 들어 오른편의 전봇대 중에서 선택된 전봇대의 번호가 라면, 2와 4를 연결할 때 꼬이게 됩니다. 또한, N이 최대 10만이기…","fields":{"slug":"/boj-1365/"},"frontmatter":{"date":"April 03, 2024","title":"[백준/BOJ] 1365. 꼬인 전깃줄 (파이썬)","tags":["PS","BOJ","백준","Python","다이나믹프로그래밍","이분탐색","LIS"]},"rawMarkdownBody":"\n## ☘️ 문제\n\nhttps://www.acmicpc.net/problem/1365\n\n## ☘️ 풀이\n\n대표적인 LIS(최장 증가 부분 수열) 문제입니다.\n\n전깃줄이 꼬여있지 않기 위해서는 오른편에서 연결된 전봇대 번호가 순서대로 증가해야 합니다. 예를 들어 오른편의 전봇대 중에서 선택된 전봇대의 번호가 `2 4 1`라면, 2와 4를 연결할 때 꼬이게 됩니다. 또한, N이 최대 10만이기 때문에 이분탐색을 활용한 LIS 문제로 풀어야 합니다.\n\n문제에서는 잘라내야 할 전선의 수를 구해야 하기 때문에, 전체 전선의 수(N)개에서 LIS의 길이를 빼면 됩니다.\n\n## ☘️ 전체 코드 (파이썬)\n\n```python\nimport sys\n\ninput = sys.stdin.readline\n\n\ndef lowerBound(lis, target):\n    left, right = 0, len(lis) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if lis[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    return right\n\n\nn = int(input())\nnumbers = list(map(int, input().split()))\n\nlis = [numbers[0]]\nfor i in range(1, n):\n    if lis[-1] < numbers[i]:\n        lis.append(numbers[i])\n    else:\n        index = lowerBound(lis, numbers[i])\n        lis[index] = numbers[i]\n\nprint(n - len(lis))\n```\n"},{"excerpt":"☘️ 문제 https://www.acmicpc.net/problem/11066 ☘️ 풀이 (C1, C2, C3, C4)로 묶인 임시 파일과 (C5, C6)으로 묶인 임시 파일은 합치는 경우, 발생하는 비용은 C1 + C2 + ... + C6 입니다. 이렇게 합칠 때마다, 구성 요소들의 파일 크기들을 모두 더하게 됩니다. 연속된 파일들끼리 합치기 때문에 누적합…","fields":{"slug":"/boj-11066/"},"frontmatter":{"date":"April 03, 2024","title":"[백준/BOJ] 11066. 파일 합치기 (파이썬/자바)","tags":["PS","BOJ","백준","Python","Java","다이나믹프로그래밍"]},"rawMarkdownBody":"\n## ☘️ 문제\n\nhttps://www.acmicpc.net/problem/11066\n\n## ☘️ 풀이\n\n(C1, C2, C3, C4)로 묶인 임시 파일과 (C5, C6)으로 묶인 임시 파일은 합치는 경우, 발생하는 비용은 C1 + C2 + ... + C6 입니다. 이렇게 합칠 때마다, 구성 요소들의 파일 크기들을 모두 더하게 됩니다. 연속된 파일들끼리 합치기 때문에 **누적합**을 이용해서 최적화를 할 수 있습니다.\n\n연속된 파일끼리 합치기 때문에 $$C_{start}$$부터 $$C_{end}$$까지 합치는 비용을 다음과 같이 표현할 수 있습니다.\n\n> $$C_{start}$$부터 $$C_{end}$$까지 합치는 비용 = $$C_{start}$$부터 $$C_{mid}$$까지 합치는 비용 + $$C_{mid + 1}$$부터 $$C_{end}$$까지 합치는 비용 + $$C_{start}$$부터 $$C_{end}$$까지의 파일 크기 합 (단, start <= mid <= end)\n\n$$C_{start}$$부터 $$C_{end}$$까지의 파일 크기 합은 고정되어 있습니다. 따라서, $$C_{start}$$부터 $$C_{end}$$까지 합치는 비용의 최소 값을 구하기 위해서는 [ $$C_{start}$$부터 $$C_{mid}$$까지 합치는 비용 + $$C_{mid + 1}$$부터 $$C_{end}$$까지 합치는 비용 ]의 최소 값을 구해야 합니다. (약간 플로이드-워셜 알고리즘이랑 비슷한 느낌) mid 값을 start와 end 사이에서 하나씩 옮기며 최소 값을 구하면 됩니다.\n\nC4부터 C6까지 합치는 최소 비용을 구했다고 했을 때, 이 값은 C4부터 C6을 포함하는 구간의 합치는 최소 비용을 구할 때도 사용됩니다. (예를 들어, C1 ~ C7, C2 ~ C6, ...) 이점에서 **DP**를 생각해볼 수 있습니다. dp 배열의 값은 다음과 같이 정의했습니다.\n\n> `dp[i][j]` : `i`부터 `j`까지 합치는 최소 비용\n\n각각 파일 크기를 알고 있기 때문에, 하나씩 합쳐보며 합치는 길이를 늘립니다. 이렇게 bottom-up 방식으로 dp 배열을 채웁니다. 우리가 구해야 하는 $$C_1$$부터 $$C_K$$까지 합치는 최소 비용인 `dp[1][k]`을 구하면 됩니다.\n\n## ☘️ 전체 코드 (파이썬)\n\n```python\nimport sys\n\ninput = sys.stdin.readline\n\n\ntc = int(input())\nfor _ in range(tc):\n    k = int(input())\n    fs = [0] + list(map(int, input().split()))\n    dp = [[0] * (k + 1) for _ in range(k + 1)]\n    s = [0] * (k + 1)\n    for i in range(1, k + 1):\n        s[i] = s[i - 1] + fs[i]\n\n    for length in range(1, k + 1):\n        for start in range(1, k - length + 1):\n            dp[start][start + length] = (\n                min(\n                    [\n                        dp[start][start + t] + dp[start + t + 1][start + length]\n                        for t in range(length)\n                    ]\n                )\n                + s[start + length]\n                - s[start - 1]\n            )\n\n    print(dp[1][k])\n```\n\n## ☘️ 전체 코드 (자바)\n\n```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static int tcs, k;\n    static int[] cost;\n    static int[][] dp;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder sb = new StringBuilder();\n        StringTokenizer st;\n\n        tcs = Integer.parseInt(br.readLine());\n        for (int tc = 0; tc < tcs; tc++) {\n            k = Integer.parseInt(br.readLine());\n            st = new StringTokenizer(br.readLine());\n            cost = new int[k + 1];\n            for (int i = 1; i < k + 1; i++) {\n                cost[i] = cost[i - 1] + Integer.parseInt(st.nextToken());\n            }\n\n            dp = new int[k + 1][k + 1];\n            for (int length = 1; length < k + 1; length++) {\n                for (int start = 1; start < k - length + 1; start++) {\n                    int end = start + length;\n                    dp[start][end] = getMinCost(start, end, length) + (cost[end] - cost[start - 1]);\n                }\n            }\n\n            sb.append(dp[1][k]).append(\"\\n\");\n        }\n\n        System.out.println(sb);\n    }\n\n    private static int getMinCost(int start, int end, int length) {\n        int result = Integer.MAX_VALUE;\n        for (int mid = 0; mid < length; mid++) {\n            result = Math.min(result, dp[start][start + mid] + dp[start + mid + 1][end]);\n        }\n        return result;\n    }\n}\n```\n"},{"excerpt":"☘️ 문제 https://www.acmicpc.net/problem/5549 ☘️ 풀이 주어진 공간안에 각각 \"J\", \"O\", \"I\"가 몇 개씩 있는지 일일이 세보는 것도 방법이지만, 시간 초과가 발생합니다. 누적합을 사용해서 최적화할 수 있습니다. 현재까지 \"J\", \"O\", \"I\"가 몇 번씩 등장했는지 기록하기 위한 2차원 배열 를 선언합니다. 현재의 bo…","fields":{"slug":"/boj-5549/"},"frontmatter":{"date":"April 01, 2024","title":"[백준/BOJ] 5549. 행성 탐사 (파이썬)","tags":["PS","BOJ","백준","Python","누적합"]},"rawMarkdownBody":"\n## ☘️ 문제\n\nhttps://www.acmicpc.net/problem/5549\n\n## ☘️ 풀이\n\n주어진 공간안에 각각 \"J\", \"O\", \"I\"가 몇 개씩 있는지 일일이 세보는 것도 방법이지만, 시간 초과가 발생합니다.\n\n**누적합**을 사용해서 최적화할 수 있습니다.\n\n현재까지 \"J\", \"O\", \"I\"가 몇 번씩 등장했는지 기록하기 위한 2차원 배열 `boardCount`를 선언합니다.\n\n- 현재의 boardCount은 왼쪽의 boardCount과 위쪽의 boardCount을 더하고 왼쪽 위의 boardCount 값을 빼면 됩니다. 왼쪽의 boardCount와 위쪽의 boardCount에 왼쪽 위의 boardCount가 중복되기 때문입니다.\n- 현재 위치에 있는 지형에 따라 boardCount를 하나 더합니다.\n\nk번 들어오는 조사 영역 구간에 대해 \"J\", \"O\", \"I\"가 몇 번 등장했는지 구하면 됩니다. 누적합으로 구해진 boardCount를 이용해서 구할 수 있습니다.\n\n<figure>\n    <img src=\"img/boj-5549-01.jpg\">\n</figure>\n\n`boardCount[a][b]`의 값은 (1, 1)부터 (a, b)의 구역안에 있는 지형의 갯수를 뜻합니다. 따라서, (a, b)와 (c, d) 사이의 구역안에 있는 지형의 갯수를 구하기 위해서는 전체 구역인 ④에서 이외의 구역인 ②, ③을 빼주고 두 번 빠진 ①을 한 번 더해줘야 합니다.\n\n## ☘️ 전체 코드 (파이썬)\n\n```python\nimport sys\n\ninput = sys.stdin.readline\n\n\nn, m = map(int, input().split())\nk = int(input())\nboard = [list(input().strip()) for _ in range(n)]\nboardCount = [[[0, 0, 0] for _ in range(m + 1)] for _ in range(n + 1)]\nfor i in range(1, n + 1):\n    for j in range(1, m + 1):\n        for t in range(3):\n            boardCount[i][j][t] = boardCount[i - 1][j][t] + boardCount[i][j - 1][t] - boardCount[i - 1][j - 1][t]\n        if board[i - 1][j - 1] == \"J\":\n            boardCount[i][j][0] += 1\n        elif board[i - 1][j - 1] == \"O\":\n            boardCount[i][j][1] += 1\n        elif board[i - 1][j - 1] == \"I\":\n            boardCount[i][j][2] += 1\n\nfor _ in range(k):\n    a, b, c, d = map(int, input().split())\n    result = [0] * 3\n    for i in range(3):\n        result[i] = boardCount[c][d][i] - boardCount[c][b - 1][i] - boardCount[a - 1][d][i] + boardCount[a - 1][b - 1][i]\n\n    print(*result)\n```\n"},{"excerpt":"☘️ 문제 https://www.acmicpc.net/problem/22862 ☘️ 풀이 조합이나 이중 반복문으로 구간을 잡고 그 구간이 홀수를 최대 k번 포함하는지 판단하여 문제를 해결할 수 있습니다. 하지만 이런 방법으로는 시간 초과가 발생할 것입니다. 이중 반복문으로 구간을 잡는다면, 구간을 잡고 그 안에서 홀수 갯수를 검사하기 위해 반복문이 한번 더 …","fields":{"slug":"/boj-22862/"},"frontmatter":{"date":"April 01, 2024","title":"[백준/BOJ] 22862. 가장 긴 짝수 연속한 부분 수열 (large) (파이썬)","tags":["PS","BOJ","백준","Python","투포인터"]},"rawMarkdownBody":"\n## ☘️ 문제\n\nhttps://www.acmicpc.net/problem/22862\n\n## ☘️ 풀이\n\n조합이나 이중 반복문으로 구간을 잡고 그 구간이 홀수를 최대 k번 포함하는지 판단하여 문제를 해결할 수 있습니다. 하지만 이런 방법으로는 시간 초과가 발생할 것입니다. 이중 반복문으로 구간을 잡는다면, 구간을 잡고 그 안에서 홀수 갯수를 검사하기 위해 반복문이 한번 더 필요하기 때문에 총 삼중 반복문이 동작합니다.\n\n**투포인터**를 이용해서 구간을 잡고 하나씩 이동해보며 최장 길이를 구하면 됩니다. 홀수를 k번 삭제할 수 있다는 것은 구간에 홀수를 최대 k개까지 포함할 수 있다는 뜻입니다. 지금까지 삭제(포함)한 횟수를 기록하기 위한 `count` 변수를 선언했습니다.\n\n- `left`의 숫자가 홀수인 경우\n  - `left`를 하나 이동시킵니다.\n  - `right`가 `left`보다 더 큰 경우(오른쪽에 있는 경우)면 상관없지만, 더 작은 경우(왼쪽에 있는 경우)에는 `left`와 맞춰줍니다.\n  - 이전에 삭제한 적이 있다면, `count`의 횟수를 하나 줄입니다.\n- `right`의 숫자가 짝수인 경우\n  - 현재 구간의 길이를 구하고 지금까지의 최대 길이와 비교하여 갱신합니다.  \n    구해야 하는 구간은 홀수가 제외된 짝수들의 구간입니다. 현재 구간의 길이에서 `count`(구간에 포함된 홀수의 갯수)만큼 빼주어야 합니다. 즉, 현재 짝수로 이루어져 있는 연속한 부분 수열의 길이는 `right + 1 - left - count`입니다.\n  - `right`를 하나 이동시킵니다.\n- `right`의 숫자가 홀수인데, 아직 더 삭제할 수 있는 경우 = 아직 더 길이를 늘려볼 수 있는 경우\n  - `right`에 해당하는 홀수를 삭제(포함)합니다. → `count + 1`\n  - `right`를 하나 이동시킵니다.\n- `right`의 숫자가 홀수인데, 더이상 삭제하지 못하는 경우\n  - `left`를 하나 이동시킵니다.\n\n## ☘️ 전체 코드 (파이썬)\n\n```python\nimport sys\n\ninput = sys.stdin.readline\n\n\nn, k = map(int, input().split())\nnumbers = list(map(int, input().split()))\n\nleft, right = 0, 0\nanswer = 0\ncount = 0\n\nwhile left < n and right < n:\n    if numbers[left] % 2 != 0:\n        left += 1\n        right = max(left, right)\n        count = max(0, count - 1)\n    elif numbers[right] % 2 == 0:\n        answer = max(answer, right + 1 - left - count)\n        right += 1\n    elif count < k:\n        right += 1\n        count += 1\n    else:\n        left += 1\n\n\nprint(answer)\n```\n"},{"excerpt":"☘️ 문제 https://www.acmicpc.net/problem/13144 ☘️ 풀이 조합이나 이중 반복문으로 구간을 잡고 그 구간에 반복되는 숫자가 있는지 검사하는 방법으로 문제를 해결할 수 있습니다. 하지만 이런 방법으로는 시간 초과가 발생할 것입니다. 이중 반복문으로 구간을 잡는다면, 구간을 잡고 그 안에서 검사하기 위해 반복문이 한번 더 필요하기 …","fields":{"slug":"/boj-13144/"},"frontmatter":{"date":"April 01, 2024","title":"[백준/BOJ] 13144. List of Unique Numbers (파이썬)","tags":["PS","BOJ","백준","Python","투포인터"]},"rawMarkdownBody":"\n## ☘️ 문제\n\nhttps://www.acmicpc.net/problem/13144\n\n## ☘️ 풀이\n\n조합이나 이중 반복문으로 구간을 잡고 그 구간에 반복되는 숫자가 있는지 검사하는 방법으로 문제를 해결할 수 있습니다. 하지만 이런 방법으로는 시간 초과가 발생할 것입니다. 이중 반복문으로 구간을 잡는다면, 구간을 잡고 그 안에서 검사하기 위해 반복문이 한번 더 필요하기 때문에 총 삼중 반복문이 동작합니다.\n\n**투포인터**를 사용해서 구간을 잡고 하나씩 이동해가며 새로 이동한 숫자가 다시 등장한 숫자인지 새로 등장한 숫자인지 판단하면 됩니다.\n\n구간 안에 숫자가 포함되었는지 판단하기 위한 배열(`isVisited`)이 필요합니다. `left`와 `right`의 값을 각각 0으로 두고 다음과 같이 동작합니다.\n\n- `right`의 숫자가 아직 등장하지 않은 새로운 숫자인 경우\n  1.  `isVisited`에 포함됨을 표시합니다.\n  2.  정답(`answer`)에 새로이 만들 수 있는 구간 조합의 갯수를 더합니다.  \n      지금까지 만들어진 구간이 `1 4 5`(길이 3)이고 구간에 새로 들어오는 숫자가 `7`(길이 1)이라면, 새로 만들 수 있는 구간 조합의 갯수는 새로 만들어지는 구간의 길이(4)만큼 만들어집니다. (`1 7`, `4 7`, `5 7`, `7`) `left`와 `right`를 모두 포함하는 구간의 길이는 `right + 1 - left`입니다.\n  3.  right를 하나 이동합니다.\n- `right`의 숫자가 이전에 등장한 숫자인 경우\n  1.  `left`를 이동시키기 전에 `left`의 숫자는 구간에서 나오게 되기 때문에 `isVisited`에서 포함되지 않음으로 표시합니다.\n  2.  `left`를 하나 이동합니다.\n\n## ☘️ 전체 코드 (파이썬)\n\n```python\nimport sys\n\ninput = sys.stdin.readline\n\n\nn = int(input())\nnumbers = list(map(int, input().split()))\nisVisited = [False] * 100001\n\nleft, right = 0, 0\nanswer = 0\n\nwhile left < n and right < n:\n    if not isVisited[numbers[right]]:\n        isVisited[numbers[right]] = True\n        answer += right + 1 - left\n        right += 1\n    else:\n        isVisited[numbers[left]] = False\n        left += 1\n\nprint(answer)\n```\n"},{"excerpt":"HTTP와 HTTPS HTTP(Hyper Text Transfer Protocol)는 서버/클라이언트 모델에 따라 데이터를 주고 받기 위한 프로토콜입니다. 즉, HTTP는 인터넷에서 하이퍼 텍스트를 교환하기 위한 통신 규약으로, 80번 포트를 사용하고 있습니다. HTTP의 문제점 HTTP는 평문 통신이기 때문에 도청이 가능하다. 통신 상대를 확인하지 않기…","fields":{"slug":"/http-vs-https/"},"frontmatter":{"date":"March 26, 2024","title":"[Network] HTTP와 HTTPS","tags":["HTTP","HTTPS","Network","네트워크","공개키","대칭키","비대칭키","SSL"]},"rawMarkdownBody":"\n<figure>\n    <img src=\"img/http-vs-https-01.png\">\n    <figcaption>출처: https://www.cloudflare.com/ko-kr/learning/ssl/what-is-https/</figcaption>\n</figure>\n\n## HTTP와 HTTPS\n\nHTTP(Hyper Text Transfer Protocol)는 서버/클라이언트 모델에 따라 데이터를 주고 받기 위한 프로토콜입니다. 즉, HTTP는 인터넷에서 하이퍼 텍스트를 교환하기 위한 통신 규약으로, 80번 포트를 사용하고 있습니다.\n\n### HTTP의 문제점\n\n- HTTP는 평문 통신이기 때문에 도청이 가능하다.\n- 통신 상대를 확인하지 않기 때문에 위장이 가능하다.\n- 완전성(정확성)을 증명할 수 없기 때문에 조작이 가능하다.\n\nHTTPS(HTTP over SSL, HTTP over TLS, HTTP Secure)는 HTTP에 데이터 암호화가 추가된 프로토콜이고, HTTP와 달리 443번 포트를 사용합니다. HTTPS의 가장 큰 특징은 HTTP가 가지고 있던 보안 문제들을 해결한다는 것입니다. 즉, HTTPS는 **암호화, 인증, 완전성 보장**을 지원합니다.\n\n## SSL과 TLS\n\n넷스스케이프가 SSL(Secure Socket Layer)을 발명하고, 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로 넘어가면서 TLS(Transport Layer Security)로 이름이 바뀌었습니다. TLS 1.0은 SSL 3.0을 계승합니다.  \n물론 TLS가 발전하면서 차이점도 존재하지만, 동작 방식은 유사하니 이 글에서는 같은 의미로 말합니다.\n\n## 대칭키 암호화와 비대칭키 암호화\n\n### 대칭키 암호화\n\n<figure>\n    <img src=\"img/http-vs-https-02.png\">\n    <figcaption>출처: https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences</figcaption>\n</figure>\n\n- 클라이언트와 서버가 동일한 키를 사용하여 암호화/복호화를 진행\n- 키가 노출되면 매우 위험하지만, 연산 속도가 빠름\n\n그런데, 이 대칭키를 어떻게 양쪽이 공유를 할까요? 대칭키가 중간에 갈취 당한다면 큰 문제일 것입니다. 이러한 대칭키 암호화 방식의 한계로, 비대칭키 암호화 방식이 등장했습니다.\n\n### 비대칭키(공개키) 암호화\n\n<figure>\n    <img src=\"img/http-vs-https-03.png\">\n    <figcaption>출처: https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences</figcaption>\n</figure>\n\n- 두 개의 키 중 하나로 암호화하면, 나머지 키로만 복호화가 가능\n  - 예를 들어 A 키와 B 키가 하나의 쌍이라면, A 키로 암호화를 하면 B 키로 복호화를 할 수 있고, B 키로 암호화를 하면 A 키로 복호화를 할 수 있다.\n  - 둘 중 하나를 공개키라 하고, 다른 하나를 개인키로 정한다.\n- 클라이언트는 공개키를 가지고, 서버는 개인키를 가짐\n  - 공개키는 이름에서 알 수 있다시피 누구나 가질 수 있다. 대신, 개인키는 서버만 가지고 있다.\n- 키가 노출되더라도 비교적 안전하지만, 연산 속도가 느림\n\n우리가 네이버에서부터 정보를 받았을 때, 이게 진짜 네이버에서 왔는지 어떻게 알 수 있을까요?\n\n1.  네이버에서 우리에게 보내는 정보들은 그 일부가 네이버의 개인키로 암호화가 되어있다.\n2.  네이버의 개인키로 암호화된 정보를 복호화할 수 있는 것은 우리가 가진 네이버의 공개키 뿐이다.\n3.  **만약 우리가 가진 네이버의 공개키로 온전히 복호화를 할 수 있다면, 그것은 네이버에서 온 정보일 것이다.**\n\n이 예시는 단순히 인증을 이해하기 위한 예시로, 비대칭키 암호화를 사용하면 이렇게 인증을 할 수 있다는 것만 확인합니다. 실제로 서버의 인증은 이후에 설명할 SSL 인증서를 통해 진행됩니다.\n\n## SSL 인증서\n\nSSL 인증서는 클라이언트와 서버 간의 통신을 제3자가 보증해주는 전자화된 문서입니다. 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달합니다. 클라이언트는 이 인증서가 신뢰할만한 것인지 검증 후에 그 다음 절차를 진행합니다.\n\n이 SSL 인증서를 통해 위에서 언급한 HTTP의 보안 문제를 해결합니다. 즉, SSL 인증서의 기능은 크게 다음과 같습니다.\n\n1.  클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장한다.\n2.  SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.\n\n### CA(Certificate Authority)\n\n앞서 말했듯, 인증서의 역할 중 하나는 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장하는 것입니다. 그럼 누가 보증을 해줄까요? 이를 인증하는 공인된 민간 기업들이 있습니다. 이러한 기업들을 CA라 합니다. SSL을 통해서 암호화된 통신을 제공하려는 서비스는 CA를 통해 인증서를 구입해야 합니다.\n\n### SSL 인증서의 내용\n\n- **서비스의 정보** (인증서를 발급한 CA, 서비스의 도메인 등등)\n  - 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지에 대한 내용\n- **서버 측의 공개키** (공개키의 내용, 공개키의 암호화 방법)\n  - 서버와 통신할 때 사용할 공개키와 그 공개키의 암호화 방법\n\n서비스의 도메인, 공개키와 같은 정보는 서비스가 CA로부터 인증서를 구입할 때 제출해야 합니다. 이 내용들은 CA에 의해서 암호화되는데, 이때 사용하는 암호화 방식이 공개키(비대칭키) 방식입니다. **CA는 자신의 CA 개인키를 이용해서 서비스에서 제출한 인증서를 암호화하는 것입니다.** CA의 개인키는 절대로 유출되어서는 안됩니다. 그리고, 우리가 사용하는 브라우저에는 CA들의 목록과 그들의 공개키가 내장되어 있습니다.\n\n## SSL 인증서가 서비스를 보증하는 방법\n\n1.  웹 브라우저가 서버에 접속할 때 서버는 제일 먼저 클라이언트에게 인증서를 제공한다.\n2.  브라우저는 이 인증서를 발급한 CA가 자신이 내장한 CA의 리스트에 있는지를 확인한다.\n3.  확인 결과 서버에서 받은 인증서가 내장된 CA 리스트에 포함되어 있다면, 해당 CA의 공개키를 이용해서 인증서를 복호화한다.\n4.  **CA의 공개키를 이용해서 인증서를 복호화 할 수 있다는 것은 이 인증서가 CA의 개인키에 의해서 암호화 된 것을 의미한다.**\n5.  해당 CA의 개인키를 가지고 있는 CA는 해당 CA 밖에는 없기 때문에, 서버가 제공한 인증서가 CA에 의해서 올바르게 발급된 것이라는 것을 의미한다.\n6.  즉, CA에 의해서 발급된 인증서라는 것은 접속한 사이트가 CA에 의해서 검토되었다는 것을 의미하고, CA의 검토를 통과했다는 것은 해당 서비스가 신뢰 할 수 있다는 것을 의미한다.\n\n이렇게 해서 인증서가 서버의 신뢰성을 제공하는 방법을 알아봤습니다. 그런데 의문점이 남습니다. 인증서에 포함된 서버의 공개키는 어떤 용도에 사용될까요?\n\n## SSL의 동작 방법\n\n비대칭키 암호화 방식만을 사용하면 컴퓨팅 파워가 많이 소모되기 때문에 SSL 인증서에서는 **대칭키 방식과 비대칭키 방식 모두를 사용**하고 있습니다. 클라이언트와 서버가 주고 받는 실제 정보는 대칭키 방식으로 암호화하고, 이 대칭키를 비대칭키 방식으로 암호화하여 클라이언트와 서버가 공유합니다.\n\n- **실제 데이터 : 대칭키 방식**\n- **대칭키 방식의 키 : 비대칭키 방식**\n\n컴퓨터와 컴퓨터가 네트워크를 통해 통신을 할 때 내부적으로 3단계를 거칩니다.\n\n> Handshake → 전송 → 세션 종료\n\n이러한 과정에서 SSL이 어떻게 데이터를 암호화하여 전달하는지 알아봅시다.\n\n<figure>\n    <img src=\"img/http-vs-https-04.png\">\n    <figcaption>SSL Handshake는 TCP 레이어의 3-way Handshake 이후에 진행된다.</figcaption>\n</figure>\n\n1.  **SSL Handshake**\n    1.  Client Hello : 클라이언트가 서버에 접속한다. 그리고 클라이언트에서 서버에 다음과 같은 정보를 전달한다.\n        - 클라이언트에서 생성한 랜덤 데이터\n        - 클라이언트가 지원하는 암호화 방식\n        - 세션 아이디 : 이미 SSL Handshaking을 했다면 비용과 시간 절약을 위해 기존 세션을 재활용하는데 이를 위한 식별자(이 과정에서는 크게 중요하지 않다.)\n    2.  Server Hello : 서버는 Client Hello에 대한 응답으로 Server Hello 과정을 거치고, 클라이언트에 다음과 같은 정보를 전달한다.\n        - 서버에서 생성한 랜덤 데이터\n        - 서버가 지원하는 암호화 방식\n        - 인증서\n    3.  클라이언트는 서버에게서 받은 인증서가 CA가 발급한 것인지를 확인하기 위해 클라이언트에 내장된 CA 리스트를 확인한다.  \n        만약, 그 리스트에 인증서가 없다면 사용자에게 경고 메시지를 출력한다. 인증서가 CA에 의해서 발급된 것인지 확인하기 위해 내장된 CA의 공개키로 복호화를 시도한다. 만약, 복호화에 성공하면 CA의 개인키로 암호화된 것이기 때문에 신뢰할 수 있다.  \n        클라이언트는 자신이 생성한 랜덤 데이터와 서버에서 받은 랜덤 데이터를 조합하여 pre master secret이라는 키를 생성한다. 이 pre master secret이라는 키를 서버에도 전달해줘야 하는데, 이 때 **공개키 방식**으로 암호화를 한다.  \n        복호화된 인증서 안에는 서버가 생성한 공개키가 들어있다고 했었다. 클라이언트는 성공적으로 인증서를 복호화하면 서버 측에서 만든 공개키를 획득하게 된다. 클라이언트는 인증서에서 얻는 서버의 공개키로 pre master secret 값을 암호화하고 서버에 전달한다.\n    4.  서버는 그 공개키에 대한 개인키를 가지고 있기 때문에 pre master secret 값을 얻어낼 수 있다. 이제 클라이언트와 서버 모두 pre master secret 값을 공유하게 되었다. 클라이언트와 서버는 각각 일련의 과정을 통해 pre master secret에서 master secret 값을 만들어내고, 이 master secret으로 세션키를 생성한다. 이 세션키를 이용해서 서버와 클라이언트는 실제 데이터를 **대칭키 방식**으로 암호화하여 주고 받는다.\n2.  **전송(세션)**  \n    실제로 클라이언트와 서버가 데이터를 주고 받는 단계이다. 이전 단계에서 얻은 세션키를 이용하여 대칭키 방식으로 데이터를 암호화하고 상대방에게 전달한다.\n3.  **세션 종료**  \n    데이터 전송이 끝나면 서로에게 SSL 통신이 끝났음을 알린다. 이 때 통신에서 사용한 대칭키인 세션키를 폐기한다.\n\n## 참고 자료\n\n- https://www.youtube.com/watch?v=H6lpFRpyl14\n- https://www.youtube.com/watch?v=0cfUVrQW_yg&list=PLCZ-8rvakaqbplQZAoUku8uuxUgbLQm-1\n- https://opentutorials.org/course/228/4894\n- https://ko.gadget-info.com/difference-between-ssl\n"},{"excerpt":"프로젝트 시작 계기 2023년 SSAFY를 다니면서 3번의 프로젝트를 진행했고, 2024년이 되면서 프로젝트보다는 알고리즘 문제 풀이나 CS 공부를 중심적으로 해야겠다고 생각했습니다. 포트폴리오에 쓸 프로젝트는 완성되었으니 실질적인 취업 준비를 하려고 했습니다. 어떻게 하면 좋은 포트폴리오를 작성하고 취업을 잘할 수 있을까 고민하던 중, 블로그 제목에 끌…","fields":{"slug":"/whiletrue-01/"},"frontmatter":{"date":"March 14, 2024","title":"whileTrue 프로젝트 후기","tags":["whileTrue","Chrome Extension","크롬 확장 프로그램","Notion API"]},"rawMarkdownBody":"\n<div align=\"center\">\n   <img src=\"img/whileTrue_icon.png\">\n</div>\n\n## 프로젝트 시작 계기\n\n2023년 SSAFY를 다니면서 3번의 프로젝트를 진행했고, 2024년이 되면서 프로젝트보다는 알고리즘 문제 풀이나 CS 공부를 중심적으로 해야겠다고 생각했습니다. 포트폴리오에 쓸 프로젝트는 완성되었으니 실질적인 취업 준비를 하려고 했습니다.\n\n어떻게 하면 좋은 포트폴리오를 작성하고 취업을 잘할 수 있을까 고민하던 중, 블로그 제목에 끌려 이동욱 님의 글 하나를 보게 되었습니다. (https://jojoldu.tistory.com/763) 본인에게 필요한 것을 만들어보고 실제 출시도 해보면서 배운 점을 정리하는 것이 곧 포트폴리오가 된다는 내용이었습니다. 이 글을 보고 프로젝트를 배척했던 마음을 접고, 그럼 나한테 필요한 서비스가 뭐가 있을까 생각했습니다.\n\n저는 알고리즘 문제를 풀 때, 다시 풀어보고 싶은 문제를 노션에 기록하고 있었습니다. 하지만, 문제 제목, 번호, URL 등등을 하나하나 직접 옮겨 적으려니 불편한 점들이 많았습니다. 또한, 저장된 문제들을 다시 풀고자 했을 때, 문제를 랜덤으로 뽑아줬으면 좋겠다고 생각했었습니다. 이 점을 개선하고자 whileTrue 프로젝트를 시작하게 되었습니다.\n\n## 시작하기 전, 고민한 부분\n\n### 자바스크립트 vs. 타입스크립트\n\n확장 프로그램의 개발 언어를 선택해야 했습니다. 자바스크립트로 진행할 경우, 이전에 사용해 본 경험이 있기 때문에 개발 진행이 상대적으로 더 빠를 것이라 생각되었습니다.\n\n그에 반해 타입스크립트로 진행하면 사용해 본 경험이 없기에 프로젝트 진행이 늦어질 것 같았습니다. 하지만 SSAFY 프로젝트의 프론트엔드 팀원들이 모두 타입스크립트를 사용하면서 궁금하기도 했고, 한번 경험해보고 싶다고 생각했기에 타입스크립트를 선택하게 되었습니다.\n\n### 리액트를 사용할 것인가?\n\n굳이 리액트를 사용하지 않고도 확장 프로그램을 개발할 수 있습니다. 리액트 역시 경험이 없기 때문에 선택하는 데에 고민이 되었습니다.\n\n리액트를 선택하면 다음과 같은 이점이 있었기에 고민이 되었고 결국 리액트를 선택하게 되었습니다.\n\n1. 보일러 플레이트가 있다.\n\n   구글이나 GitHub에 검색하시면 크롬 확장 프로그램 개발을 위한 리액트 보일러 플레이트를 여럿 보실 수 있습니다. 이를 활용하여 확장 프로그램 구조 조금 더 쉽게 파악을 할 수 있었고 코드 관리를 더 잘할 수 있을 것 같았습니다.\n\n2. 화면 디자인이 더 수월하지 않을까? (추측)\n\n   아무래도 리액트는 프론트엔드 라이브러리다 보니 화면을 디자인하고 다루는데 더 수월할 것 같다는 생각했습니다.\n\n3. 한번 해볼까?\n\n   SSAFY에서 진행한 3번의 프로젝트 모두 자바 스프링 백엔드 역할을 맡았습니다. 리액트를 사용해 본 적이 없었기에 이번 기회에 한번 써보고자 했습니다.\n\n### 어떤 데이터베이스를 사용할 것인가?\n\n처음에는 노션 데이터베이스를 활용하고자 했으나 진행하면서 꼭 노션이어야 하는 의문이 들었습니다. 노션 API를 다루기도 쉽지 않았고, 다시 풀고 싶은 문제를 저장하고 랜덤으로 추출하는 것이 중요하지 노션이어야 할 필요가 있을까라는 생각이 들었습니다. 더욱이 사용자가 데이터베이스 칼럼을 조작하지 못하기에 에러 핸들링이 간단해지는 이점도 있었습니다.\n\n하지만, 결국 다시 노션을 선택하게 되었습니다. 사용자들이 자신이 저장한 모든 문제를 볼 수 있어야 한다고 생각했습니다. 단순히 저장하고 하나씩 추출하는 것을 넘어 사용자들이 지금까지 쌓아온 문제들을 보는 것도 의미가 있을 것이라 판단했습니다. 모든 문제를 보여주는 것은 노션이 아니어도 가능하겠지만, 노션을 활용하는 것이 사용자들에게 색다른 경험을 제공하고 또 웹페이지에서 보는 것보다는 자신의 노션에서 보는 게 접근성이 좋을 것이라 생각했습니다.\n\n## 발생한 문제와 해결 방법\n\n### 노션 API는 CORS를 지원하지 않는다.\n\n프로젝트 초반에는 단순 확장 프로그램 단독으로 동작하는 것으로 구상했습니다. 하지만, 확장 프로그램에서 직접 노션 API를 사용하려고 하니 CORS 에러가 발생했습니다. 구글링을 통해 노션 API는 CORS를 지원하지 않는다는 것을 알게 되었습니다.\n\n![출처: https://medium.com/hcleedev/web-same-origin-policy%EC%99%80-cors-%EC%97%90%EB%9F%AC-%EA%B7%B8%EB%A6%AC%EA%B3%A0-preflight-8e8ce5375ff3](img/notion-api-cors.webp)\n\n결국 백엔드까지 구축해야 된다는 것을 알게 됐고, 이 이후부터 프로젝트의 규모가 매우 커졌습니다…\n\n### 자바에서 JSON을 다루기가 만만치 않다.\n\n![초기 다이어그램: Spring 서버에서 모든 역할을 맡는다.](img/diagram1.jpg)\n\n초기 다이어그램은 위와 같습니다. 지금까지 스프링 부트로 백엔드 프로젝트를 진행해 왔기에 큰 고민 없이 스프링을 선택했습니다. 하나의 스프링 서버에서 인증, 인가를 포함한 비즈니스 로직 처리, 데이터베이스 접근과 노션 API와의 통신 등등을 담당했습니다.\n\n그러나 노션 API를 자바에서 사용하는데 불편함이 굉장히 많았습니다. JSON 형식으로 통신을 하는데 일일이 DTO를 만들어야 했고, 또 JSON의 깊이가 깊어 값을 받아오더라도 사용하는 데에 불편함이 많았습니다. 가장 큰 문제는 노션 API에서 반환되는 JSON의 키 값들이 고정되어 있지 않다는 것입니다.\n\n![number 타입 반환값](img/number-type-response.png)\n![title 타입 반환값](img/title-type-response.png)\n\n스프링에서 노션을 사용한 모든 DTO를 만드는 등의 작업은 마쳤지만, 이후 이 코드를 계속 사용하고 유지보수하기에는 어려울 것 같았습니다. 실제로 개발 도중, “난이도” 칼럼도 같이 저장해 달라는 요구 사항을 받고, 노션 API를 사용하는 부분을 수정해야 했는데 코드가 너무 복잡했고 큰 스트레스로 다가왔습니다. 결국 노션 API 사용하기 위한 Express 서버를 도입하기로 했습니다.\n\n![최종 다이어그램: Express 서버에서 Notion API를 다룬다.](img/diagram2.jpg)\n\n최종적인 시스템 아키텍처는 위와 같습니다. 자바스크립트(타입스크립트)를 활용하면 쉽게 JSON를 다룰 수 있기에 보다 편리하게 노션 API를 다룰 수 있었습니다. 비록 관리해야 하는 프로젝트가 총 3개(확장 프로그램, 스프링 백엔드, Express 백엔드)가 되었지만, 자바로 변화무쌍한 JSON 객체들을 다루지 않아도 된다는 이점이 더 크게 느껴졌습니다.\n\n이제 스프링 서버에서는 인증, 인가와 비즈니스 로직, 데이터베이스 접근의 역할을 맡게 되었고, 노션과 통신하는 부분은 Express 서버에서 맡게 되었습니다.\n\n### 어떻게 문제를 랜덤으로 뽑지?\n\n노션 API에는 데이터베이스에서 랜덤으로 뽑아주는 API가 없습니다. 처음에는 직접 데이터베이스에서 랜덤으로 선택해서 가져오는 방식으로 개발을 진행했습니다. 검색해 보시면 노션 데이터베이스에서 랜덤 값을 생성하는 방법들이 나옵니다. Formula 칼럼을 추가하여 랜덤 값을 생성하는 식을 넣으면 주기적으로 각 칼럼의 값이 랜덤값이 생성됩니다. (참고: https://medium.com/@andrewwongai/how-to-make-a-random-shuffle-gallery-view-in-notion-c1faf915c285)\n\n![Formula 칼럼을 활용해서 랜덤값을 생성할 수 있다.](img/random-column.webp)\n\n이를 활용하여 이 값으로 정렬한 후, 첫 번째 값을 반환하는 방법으로 구현했었습니다. 하지만, 사용자 경험 차원에서는 별로 좋지 않겠다는 생각을 했습니다. 사용자 입장에서는 필요 없는 정보인데 사용자의 노션에 있는 것이 보기 좋지 않을 것 같았습니다. 그리고 사용자가 기존 자신의 데이터베이스를 사용하는 경우에는 사용자가 직접 칼럼과 랜덤값을 생성하는 식을 넣어줘야 합니다. 랜덤값 칼럼이 없는 경우도 따로 에러 핸들링을 해야 했기 때문에 다른 방식을 택하게 되었습니다.\n\n그래서 현재 구현된 방식은 모든 문제를 가져와서 그중 랜덤 인덱스의 문제를 가져오는 방식입니다. 이로 인해 사용자 입장에서는 필요 없는 랜덤값 칼럼을 유지할 필요가 없어지고, 제 입장에서도 에러 핸들링을 하지 않아도 되어 관리하기 편해졌습니다. 랜덤 추출할 때마다 노션에서 모든 문제를 가져오는 것은 코스트가 많이 들 것이라 사용자의 로컬에 문제 리스트를 모두 저장하고 로컬에서 추출하는 방식으로 구현했습니다.\n\n## 남아있는 숙제\n\n1. 스프링 서버 재고\n\n   이쯤 되니 굳이 스프링 서버가 있어야 하나라는 생각이 듭니다. 아직은 Express에 자세히 알지 못해 스프링 서버를 대체할 수 없지만, 이후 Express에 대해 좀 더 공부를 하고 스프링 서버를 대체하지 않을까 싶습니다.\n\n2. 에러 핸들링\n\n   데이터베이스 공유와 같은 필수적인 에러 핸들링은 구현되어 있으나 이외는 아직 러프하게 되어있습니다. 이 부분을 더 세분화하여 사용자에게 더 자세히 에러를 알려주는 방식으로 진행할 것 같습니다.\n\n3. 비용\n\n   이건 아마 해결하지 못할 숙제일 듯합니다. 프로젝트를 오래 유지하기 위해 처음에는 비용이 발생하지 않는 방법으로 진행하려고 했습니다. 이런 이유로 확장 프로그램으로만 동작하는 방식으로 시작했습니다. 하지만 결국 AWS EC2, RDS, Codedeploy 등까지 사용하면서 비용이 발생하게 되었습니다. 프로젝트를 계속 유지시키기 위해서는 비용을 최소화해야 하기에 계속 고민할 것 같습니다.\n\n## 배우고 느낀 점\n\n1. 타입스크립트와 리액트\n\n   이번에 사용해 보면서 자바스크립트와 자바를 합친 것 같다는 느낌을 받았습니다. 필요한 부분에서는 객체 interface나 type을 지정해 주어 사용할 때 내부 값들의 접근이 쉬웠습니다. interface나 type이 복잡한 경우에는 `any`를 써서 회피할 수 있는 것도 사용하는 데에 편리했습니다. 물론 깊게 써보지는 않았지만, 자바스크립트보다는 타입스크립트를 쓰는 게 더 도움 되지 않을까 싶습니다.\n\n   리액트를 사용하면서 리액트로 시작하기 잘했다는 생각을 했습니다. 개발하다 보니 꽤 많은 화면을 만들고 조건부 랜더링을 해야 했습니다. 단순 HTML로 다뤘으면 중복되는 내용도 많고 로직을 다루기도 쉽지 않았을 것 같습니다. 이번 개발에 필요한 리액트 개발 방법만 익혀 사용했기에 제대로 알지는 못하지만, 화면별로 분리하고 관리하기 편하다고 느꼈습니다.\n\n2. 공식 문서와 친해졌다.\n\n   이번 프로젝트를 진행하면서 크롬 개발자 문서와 노션 개발자 문서 참고를 많이 했습니다. 이전에는 공식 문서를 봐야 된다는 것을 알아도 가독성이 좋지 않다는 이유로 계속 기피했습니다. 하지만, 크롬 개발자 문서나 노션 API 문서는 정리도 잘 되어있기도 했고 사용한 레퍼런스도 많지 않아 공식 문서를 계속 참고했습니다. 이번 기회를 통해 공식 문서와 친해지지 않았나 생각합니다.\n\n3. 개발을 들어가기 전에 사전 조사를 자세히 해야겠다.\n\n   발생한 문제에서 말한 것처럼 진행하면서 아키텍처나 구현 방식을 여러 번 갈아엎었습니다. 단순 확장 프로그램만 개발한다는 첫 구상에서 백엔드, 데이터베이스, 서버, CI/CD까지 규모가 매우 커졌습니다. 물론 왕도로만 갈 수는 없겠지만, 그래도 사전에 알아보고 어느 정도 구상을 해봤으면 시간을 더 많이 아낄 수 있지 않았을까 하는 아쉬움이 남습니다.\n\n4. 실제 사용자를 받는다는 두려움\n\n   단순히 프로젝트를 만들고 끝나는 것이 아니라, 실제로 다른 사람들이 내 프로젝트, 서비스를 사용한다고 하니 막연한 두려움이 생기고 더 잘 만들어야 하는 것 아닌가라는 생각이 들었습니다. 아직도 이런 마음이 없는 것은 아니지만, 개선해 나가면서 성장하는 것이고 또, 오픈 소스로 다 같이 만들어나가는 것이라 생각하며 완성했습니다. 그리고 안정적인 서비스를 만들기 위해 공부를 많이 해야겠다는 다짐하게 됐습니다.\n\n5. SSAFY를 통한 성장\n\n   사실 백엔드 기술 스택에 꽤 여러 개가 사용되었습니다. AWS의 EC2, RDS, Codedeploy, GitHub Actions, Docker, Spring, Express 등등을 도입했습니다. SSAFY의 프로젝트를 통해 경험을 이미 해보았고 사용 방법들을 알고 있었기에 큰 진입 장벽, 고민 없이 도입할 수 있었던 것 같습니다.\n\n6. 출시될 때의 뿌듯함\n\n   초반에 개발을 시작하면서 제대로 완성할 수 있을까라는 의구심이 들었습니다. 개발을 하면서도 몇 번의 큰 문제가 발생할 때마다 포기하고 싶다, 괜히 시작했나라는 생각이 들었습니다. 그래도 차근차근 하나씩 해결해나가다 보니 완성시킬 수 있었습니다. 그리고 크롬 웹 스토어의 승인을 받고 정식 출시가 되었을 때 굉장히 뿌듯했습니다.\n\n## 글을 마무리하며…\n\n앞으로 조금씩 프로젝트를 개선해 나갈 생각입니다. 상반기 채용 공고들이 나오고 있어서 큰 변화를 주지는 못하겠지만, 에러 수정 등은 꾸준히 할 예정입니다.\n\n마지막으로 프로젝트를 진행하는 데에 도움을 주신 분들께 감사 인사를 남기고 마무리하겠습니다. 먼저, ‘프로젝트는 이제 그만’이라는 닫힌 생각을 다시 열게끔 인사이트를 주신 이동욱 님께 감사드립니다. 덕분에 프로젝트를 시작할 수 있었습니다. 프로젝트에 “whileTrue”라는 이름을 붙여주시고, 페르소나가 되어주신 심부부 님, 적극적으로 의견을 내주시고 프로젝트를 지속할 수 있도록 응원해 주신 햄 님, 그리고 고민이 생기거나 결정 사항이 생길 때마다 고민 들어주시고 의견 주신 변 님까지 모두들 감사합니다.\n\n![감사합니다!](img/thankyou.gif)\n\n## 관련 링크\n\n- [GitHub](https://github.com/namgons/whileTrue)\n- [크롬 웹 스토어](https://chromewebstore.google.com/detail/whiletrue/ockglcdfpkebaiaaocinjdcpiieceocn)\n"},{"excerpt":"N+1 문제가 뭘까? 하나의 엔티티 전체를 조회하면서 그와 연관된 다른 엔티티를 조회할 때, 여러 번의 쿼리가 발생하는 문제입니다. 예를 들어, Team 엔티티와 Member 엔티티 사이에 다음과 같이 1:N(일대다)의 관계가 있다고 해보겠습니다. 그리고 각각의 엔티티는 다음과 같이 정의되어 있습니다. 총 3개의 팀이 있고, 각 팀에는 3명의 멤버가 있습…","fields":{"slug":"/n+1-problem/"},"frontmatter":{"date":"September 30, 2023","title":"[JPA] N+1 문제와 해결법","tags":["Spring","JPA","N+1"]},"rawMarkdownBody":"\n## N+1 문제가 뭘까?\n\n하나의 엔티티 전체를 조회하면서 그와 연관된 다른 엔티티를 조회할 때, 여러 번의 쿼리가 발생하는 문제입니다. 예를 들어, Team 엔티티와 Member 엔티티 사이에 다음과 같이 1:N(일대다)의 관계가 있다고 해보겠습니다.\n\n<figure>\n    <img src=\"img/n+1-01.png\">\n</figure>\n\n그리고 각각의 엔티티는 다음과 같이 정의되어 있습니다.\n\n```java\n@Getter\n@Entity\n@NoArgsConstructor\n@Builder\n@AllArgsConstructor\npublic class Member {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"member_id\")\n    private Long id;\n\n    private String name;\n\n    @ManyToOne\n    @JoinColumn(name = \"team_id\")\n    private Team team;\n\n    public void joinNewTeam(Team team) {\n        this.team = team;\n    }\n\n}\n```\n\n```java\n@Getter\n@Entity\n@NoArgsConstructor\npublic class Team {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"team_id\")\n    private Long id;\n\n    private String name;\n\n    @OneToMany(mappedBy = \"team\", cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    private List<Member> memberList = new ArrayList<>();\n\n    @Builder\n    public Team(Long id, String name, List<Member> memberList) {\n        this.id = id;\n        this.name = name;\n        if (memberList != null) {\n            this.memberList = memberList;\n        }\n    }\n\n    public void addNewMember(Member member) {\n        this.memberList.add(member);\n        member.joinNewTeam(this);\n    }\n}\n```\n\n총 3개의 팀이 있고, 각 팀에는 3명의 멤버가 있습니다.\n\n```java\n@BeforeEach\npublic void setup() {\n    List<Team> teamList = new ArrayList<>();\n\n    for (int i = 0; i < 3; i++) {\n        Team team = Team.builder().name(\"팀 \" + i).build();\n\n        for (int j = 0; j < 3; j++) {\n            team.addNewMember(Member.builder().name(\"멤버 \" + i + j).build());\n        }\n\n        teamList.add(team);\n        teamRepository.saveAll(teamList);\n    }\n}\n```\n\n```java\n@Service\n@RequiredArgsConstructor\npublic class TeamService {\n\n    private final TeamRepository teamRepository;\n\n    @Transactional\n    public List<String> findAllMemberNameFromAllTeam() {\n        System.out.println(\"\\n========== 모든 팀 조회 ==========\");\n        List<Team> teamList = teamRepository.findAll();\n\n        return findAllMemberName(teamList);\n    }\n\n    private List<String> findAllMemberName(List<Team> teamList) {\n        System.out.println(\"\\n========== 각 팀의 멤버 조회 ==========\");\n\n        List<String> nameList = new ArrayList<>();\n        for (Team team : teamList) {\n            nameList.addAll(team.getMemberList().stream().map(Member::getName).toList());\n        }\n        return nameList;\n    }\n}\n```\n\n우리는 모든 팀을 조회하고 각 팀에 속해 있는 모든 멤버들의 이름을 가져오고 싶습니다. 이것을 하나의 쿼리로 처리하고 싶지만 실제 실행된 쿼리를 보면 여러 쿼리가 동작한다는 것을 알 수 있는데, 이것이 N+1 문제입니다.\n\n<figure>\n    <img src=\"img/n+1-02.png\">\n</figure>\n\n처음에 모든 팀을 가져오는 쿼리가 실행되고(1), 총 N개의 팀을 가져오게 됩니다. 그리고 각 팀의 멤버들에 접근해야 하기 때문에 또 다시 각 팀에 대해서 쿼리가 실행됩니다.(N)\n\n우리의 예제에서는 총 3개의 팀이 있기 때문에, 모든 팀을 조회하는 쿼리 1개와 3개의 각 팀의 멤버들에 접근하는 쿼리 3개가 실행되는 것을 볼 수 있습니다.\n\n## 무엇이 문제인데?\n\n우리는 각 팀에 속해 있는 모든 멤버들의 이름을 가져오고 싶습니다. 하지만 기존의 방식대로 하면 팀들을 조회하는 쿼리와 각 팀의 멤버들을 조회하는 쿼리가 따로 나가기 때문에 문제가 됩니다. 위에서 든 예시에서는 팀의 수가 매우 적기 때문에 추가적으로 실행되는 쿼리의 수가 적지만, 만약 팀의 수가 매우 많은 경우에는 팀의 수만큼 쿼리가 실행되기 때문에 성능에 큰 문제가 될 수 있습니다.\n\n따라서, 쿼리가 따로 실행되는 것이 아니라 한 번의 쿼리로 팀의 정보와 각 팀들의 정보를 가져오는 방법이 없는지 고민해보아야 합니다.\n\n## 왜 발생할까?\n\nN+1 문제가 왜 발생할까요? 그럼 반대로 생각해보겠습니다. N+1 문제가 발생하지 않도록 하려면 JPA가 어떻게 동작해야 할까요?\n\n모든 팀의 조회하는 쿼리와 함께 각 팀에 연관된 엔티티도 모두 조회하는 쿼리도 포함시켜서 한 번에 처리하고 전부 영속성 컨텍스트에 저장해야 합니다. 하지만, JPA가 기본적으로 이렇게 동작한다면 이 역시도 큰 문제가 될 것입니다.\n\n## FetchType.LAZY(지연 로딩)을 하면 괜찮지 않을까?\n\nJpaRepository의 메소드들은 JPQL로 실행되는데, JPQL은 Fetch 전략과 상관없이 일단 SQL로 변환되어 실행됩니다. 즉시 로딩, 지연 로딩 같은 글로벌 Fetch 전략과 상관없이 일단 모든 팀의 정보를 가져옵니다. 그 이후에 JPA는 엔티티에 설정된 Fetch 전략에 따라 연관된 엔티티를 바로 가져올지 말지 판단합니다.\n\n따라서, N+1 문제는 즉시 로딩이나 지연 로딩과 상관 없습니다. `FetchType.EAGER`인 경우에는 모든 팀을 조회하는 쿼리가 수행된 이후에 추가적인 쿼리도 바로 연이어 나가고, `FetchType.LAZY`인 경우에는 추가 쿼리가 바로 나가지는 않지만, 각 팀에 접근해서 멤버들을 조회할 때 쿼리가 나가게 됩니다.\n\n즉, 즉시 로딩이나 지연 로딩은 연관된 엔티티를 가져오는 쿼리가 언제 나가느냐에 차이가 있을 뿐, 결과적으로 둘 다 추가적인 쿼리를 통해서 연관된 엔티티를 가져옵니다.\n\n## 그럼 어떻게 해결하지?\n\n대표적인 해결 방법으로는 Fetch Join, @EntityGraph, BatchSize를 이용하는 방법이 있습니다.\n\n## Fetch Join\n\n- 코드 블럭으로 보기\n  ```java\n  @Query(\"select t from Team t join fetch t.memberList\")\n  List<Team> findAllFetchJoin();\n  ```\n  ```sql\n  select\n      team0_.team_id as team_id1_1_0_,\n      memberlist1_.member_id as member_i1_0_1_,\n      team0_.name as name2_1_0_,\n      memberlist1_.name as name2_0_1_,\n      memberlist1_.team_id as team_id3_0_1_,\n      memberlist1_.team_id as team_id3_0_0__,\n      memberlist1_.member_id as member_i1_0_0__\n  from\n      team team0_\n  inner join\n      member memberlist1_\n          on team0_.team_id=memberlist1_.team_id\n  ```\n\nFetch Join은 일반 SQL에서 제공하는 기능이 아닌, JPQL에서 성능 최적화를 위해 제공하는 기능입니다. Fetch Join을 사용하면 연관된 엔티티나 컬렉션을 한 번의 SQL 쿼리로 가져올 수 있습니다.\n\n<figure>\n    <img src=\"img/n+1-03.png\">\n</figure>\n\n<figure>\n    <img src=\"img/n+1-04.png\">\n</figure>\n\n그리고 위 사진에서 볼 수 있다시피 Fetch Join은 Inner Join으로 수행됩니다.\n\n## @EntityGraph\n\n- 코드 블럭으로 보기\n  ```java\n  @EntityGraph(attributePaths = \"memberList\")\n  @Query(\"select t from Team t\")\n  List<Team> findAllEntityGraph();\n  ```\n  ```sql\n  select\n      team0_.team_id as team_id1_1_0_,\n      memberlist1_.member_id as member_i1_0_1_,\n      team0_.name as name2_1_0_,\n      memberlist1_.name as name2_0_1_,\n      memberlist1_.team_id as team_id3_0_1_,\n      memberlist1_.team_id as team_id3_0_0__,\n      memberlist1_.member_id as member_i1_0_0__\n  from\n      team team0_\n  left outer join\n      member memberlist1_\n          on team0_.team_id=memberlist1_.team_id\n  ```\n\n@EntityGraph의 `attributePaths`에 쿼리 수행 시에 같이 가져올 필드명을 지정하면 한 번에 모두 가져오게 됩니다.\n\n<figure>\n    <img src=\"img/n+1-05.png\">\n</figure>\n\n<figure>\n    <img src=\"img/n+1-06.png\">\n</figure>\n\n주목할 점은 Fetch Join은 Inner Join으로 수행되는 반면, @EntityGraph는 Outer Join으로 수행된다는 것입니다.\n\n## Fetch Join과 @EntityGraph의 문제점\n\n1. 단순 Fetch Join만을 사용하면 카테시안 곱이 발생하기 때문에 일대다 관계의 일(1) 부분에서 중복 발생하게 됩니다.\n\n   ```java\n   @Test\n   void joinFetch() {\n\n       System.out.println(\"\\n========== Fetch Join 테스트 ==========\");\n       System.out.println(\"\\n========== 모든 팀 조회 ==========\");\n\n       List<Team> allTeams = teamRepository.findAllFetchJoin();\n\n       System.out.println(\"\\n========== 모든 팀 조회 끝 ==========\");\n       System.out.println(\"\\n========== 각 팀의 멤버 조회 ==========\");\n\n       List<String> allMemberNames = new ArrayList<>();\n       for (Team team : allTeams) {\n           System.out.println(team.getName());\n           for (Member member : team.getMemberList()) {\n               System.out.println(member.getName());\n               allMemberNames.add(member.getName());\n           }\n       }\n\n       System.out.println(\"\\n========== 각 팀의 멤버 조회 끝 ==========\");\n       System.out.println(\"allTeams = \" + allTeams.size());\n       System.out.println(\"allMemberNames = \" + allMemberNames.size());\n\n   }\n   ```\n\n   <figure>\n    <img src=\"img/n+1-07.png\">\n   </figure>\n\n   <figure>\n    <img src=\"img/n+1-08.png\">\n   </figure>\n\n   이를 해결하기 위해서는 JPQL의 DISTINCT 키워드를 사용하거나 Set 컬렉션을 이용해서 중복되는 값을 제거해야 합니다.\n\n   ```java\n   @Query(\"select distinct t from Team t join fetch t.memberList\")\n   List<Team> findAllDistinctFetchJoin();\n   ```\n\n   ```java\n   @EntityGraph(attributePaths = \"memberList\")\n   @Query(\"select distinct t from Team t\")\n   List<Team> findAllDistinctEntityGraph();\n   ```\n\n   ```java\n   // Set을 이용하는 경우\n\n   @Query(\"select t from Team t join fetch t.memberList\")\n   Set<Team> findAllFetchJoinBySet();\n   ```\n\n2. 페이징 처리가 어렵습니다. Fetch Join과 @EntityGraph에서는 페이징 API를 지원하지 않기 때문에 페이징 처리를 할 수 없습니다.\n\n## BatchSize\n\nBatchSize 값을 설정하면 한 번의 쿼리로 연관된 데이터 몇 개를 가져올 지를 지정할 수 있습니다. 예를 들어 70개의 가져올 데이터가 있고 BatchSize가 30인 경우, 총 3번의 쿼리로 30개, 30개, 10개씩 가져오게 됩니다. 하나의 쿼리로 모든 데이터를 조회할 수는 없지만(전체 데이터 수가 BatchSize보다 큰 경우), 기존의 N+1 문제에서 발생한 쿼리 수보다는 적게 발생합니다.\n\n## 참고\n\n- [[블로그] JPA N+1 문제 및 해결방안 (향로 님)](https://jojoldu.tistory.com/165)\n- [[블로그] JPA N+1 발생 케이스와 해결책 (최진영 님)](https://brunch.co.kr/@jinyoungchoi95/2)\n- [[인프런 강의] 자바 ORM 표준 JPA 프로그래밍 - 기본편 (김영한 님)](https://www.inflearn.com/course/ORM-JPA-Basic)\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}