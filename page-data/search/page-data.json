{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"프록시(Proxy)란? 프록시 서버는 클라이언트가 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킨다.(출처:위키백과) 즉, 클라이언트와 서버 사이에 위치해서 중간자 역할을 하는 것이 프록시 서버이다. 그리고 이 프록시 서버가 어디에 위치해있는지에 따라 포워드 프록시 서버와 리버스 프록시 서버…","fields":{"slug":"/proxy-overview/"},"frontmatter":{"date":"November 24, 2024","title":"[Network] Forward Proxy와 Reverse Proxy","tags":["Proxy","Forward Proxy","Reverse Proxy"]},"rawMarkdownBody":"\n## 프록시(Proxy)란?\n\n프록시 서버는 클라이언트가 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램을 가리킨다.(출처:위키백과) 즉, 클라이언트와 서버 사이에 위치해서 중간자 역할을 하는 것이 프록시 서버이다.\n\n그리고 이 프록시 서버가 어디에 위치해있는지에 따라 포워드 프록시 서버와 리버스 프록시 서버로 나뉜다.\n\n## 포워드 프록시(Forward Proxy)\n\n클라이언트 앞 단에 위치하여, 클라이언트 대신 애플리케이션 서버와 통신 후 요청에 대한 응답을 클라이언트에게 반환하는 형태이다.\n\n### 포워드 프록시를 사용해서 얻을 수 있는 이점\n\n- 캐싱\n\n  이전의 요청과 동일한 요청을 하는 경우, 서버에 다시 요청하는 대신 프록시 서버에서 저장된 응답을 반환할 수 있다.\n  정적 컨텐츠, 클라이언트의 요청에 대한 서버의 응답, DNS 조회 결과 등이 저장된다.\n  주로 여러 클라이언트가 공유하는 데이터를 캐싱한다.\n\n- 접근 제어\n\n  정부나 공공기관, 기업 등에서 정해진 웹 서버에만 접근하도록 제한하는 경우가 있는데, 이때 프록시 서버에 정해진 웹 서버에만 접근할 수 있도록 제한할 수 있다.\n\n- 보안\n\n  서버와의 통신은 프록시 서버를 통해 진행되기 때문에, 서버로부터 클라이언트의 정보를 숨길 수 있다.\n\n## 리버스 프록시(Reverse Proxy)\n\n애플리케이션 서버 앞에 위치하여, 클라이언트는 인터넷을 통해 리버스 프록시 서버와 통신하고 이후, 리버스 프록시 서버가 클라이언트의 요청을 애플리케이션 서버에 전달하는 형태이다.\n\n리버스 프록시 서버는 DMZ에 속하게 된다. 외부 네트워크(인터넷)와 내부 네트워크(WAS) 사이에 위치하여, 외부에서 내부로의 직접적인 접근을 막고 내부 네트워크를 보호하는 영역을 DMZ라고 한다. (AWS VPC의 Public Subnet이 DMZ에 속한다.)\n\n### 리버스 프록시를 사용해서 얻을 수 있는 이점\n\n- 캐싱\n\n  포워드 프록시 서버와 마찬가지로 중복된 요청에 대해 이미 저장된 응답을 전달하여 부하를 줄일 수 있다.\n  정적 컨텐츠, API 응답 데이터, TLS 세션 정보 등이 저장된다.\n  주로 WAS의 부하와 클라이언트 응답 속도 개선을 위해 요청에 대한 응답을 캐싱한다.\n\n- 보안\n\n  클라이언트는 애플리케이션과 직접적으로 통신하는 것이 아니라 리버스 프록시 서버와 통신하게 되므로 애플리케이션 서버의 IP 주소 등을 숨길 수 있다.\n\n- 로드밸런싱\n\n  여러 대의 서버를 사용할 경우, 로드밸런싱을 통해 서버에 대한 부하를 줄일 수 있다.\n\n### 백엔드에 대한 요청인지, 프론트엔드에 대한 요청인지 어떻게 구분할 수 있을까?\n\n- URL 패턴\n\n  `/api`로 시작하는 URL은 백엔드에 대한 요청, 이외의 `/`로 시작하는 요청은 프론트엔드에 대한 요청으로 구분할 수 있다.\n\n- 포트 번호\n\n  프론트엔드는 80번 혹은 443번 포트 번호를 사용하고, 백엔드는 3000번 혹은 8080번 포트 번호를 사용하게끔 해서 포트 번호를 통해 프론트엔드 요청과 백엔드 요청을 구분할 수 있다.\n\n- 헤더 정보\n\n  Request Header에 특정 키를 확인해서 API 요청인지 확인할 수 있다.\n"},{"excerpt":"HTTP와 HTTPS HTTP(Hyper Text Transfer Protocol)는 서버/클라이언트 모델에 따라 데이터를 주고받기 위한 프로토콜이다. 즉, HTTP는 인터넷에서 하이퍼 텍스트를 교환하기 위한 통신 규약이며, 80번 포트를 사용한다. HTTP의 문제점 HTTP는 평문 통신이기 때문에 도청이 가능하다. HTTP는 통신 상대를 검증하지 않기 …","fields":{"slug":"/http-vs-https/"},"frontmatter":{"date":"September 23, 2024","title":"[Network] HTTP와 HTTPS","tags":["HTTP","HTTPS","Network","네트워크","공개키","대칭키","비대칭키","SSL"]},"rawMarkdownBody":"\n<figure>\n    <img src=\"img/http-vs-https-01.png\">\n    <figcaption>출처: https://www.cloudflare.com/ko-kr/learning/ssl/what-is-https/</figcaption>\n</figure>\n\n## HTTP와 HTTPS\n\nHTTP(Hyper Text Transfer Protocol)는 서버/클라이언트 모델에 따라 데이터를 주고받기 위한 프로토콜이다. 즉, HTTP는 인터넷에서 하이퍼 텍스트를 교환하기 위한 통신 규약이며, 80번 포트를 사용한다.\n\n### HTTP의 문제점\n\n- HTTP는 평문 통신이기 때문에 도청이 가능하다.\n- HTTP는 통신 상대를 검증하지 않기 때문에 피싱이나 중간자 공격(Man-in-the-Middle Attack)에 취약하다.\n- 데이터의 무결성을 보장하지 않기 때문에, 데이터가 전송 중에 변경되거나 조작될 수 있다.\n\nHTTPS(HTTP over SSL, HTTP over TLS, HTTP Secure)는 HTTP에 데이터 암호화가 추가된 프로토콜이며, HTTP와 달리 443번 포트를 사용한다. HTTPS의 가장 큰 특징은 HTTP가 가지고 있던 보안 문제를 해결한다는 것이다. 즉, HTTPS는 **암호화, 인증, 완전성 보장**을 지원한다.\n\n## SSL과 TLS\n\n넷스케이프가 SSL(Secure Socket Layer)을 발명하고, 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로 넘어가면서 TLS(Transport Layer Security)로 이름이 바뀌었다. TLS 1.0은 SSL 3.0을 계승한 것이다.  \n물론 TLS가 발전하면서 차이점도 존재하지만, 동작 방식은 유사하니 이 글에서는 같은 의미로 설명한다.\n\n## 대칭키 암호화와 비대칭키 암호화\n\n### 대칭키 암호화\n\n<figure>\n    <img src=\"img/http-vs-https-02.png\">\n    <figcaption>출처: https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences</figcaption>\n</figure>\n\n- 클라이언트와 서버가 동일한 키를 사용하여 암호화/복호화를 진행한다.\n- 키가 노출되면 매우 위험하지만, 연산 속도가 빠르다.\n\n그런데, 이 대칭키를 어떻게 양쪽이 공유할 수 있을까? 대칭키가 중간에 갈취당한다면 큰 문제가 될 것이다. 이러한 대칭키 암호화 방식의 한계로, 비대칭키 암호화 방식이 등장하였다.\n\n### 비대칭키(공개키) 암호화\n\n<figure>\n    <img src=\"img/http-vs-https-03.png\">\n    <figcaption>출처: https://www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences</figcaption>\n</figure>\n\n- 두 개의 키 중 하나로 암호화하면, 나머지 키로만 복호화가 가능하다.\n  - 예를 들어 A 키와 B 키가 하나의 쌍이라면, A 키로 암호화하면 B 키로 복호화할 수 있고, B 키로 암호화하면 A 키로 복호화할 수 있다.\n  - 둘 중 하나를 공개키라 하고, 다른 하나를 개인키로 정한다.\n- 클라이언트는 공개키를 가지고, 서버는 개인키를 가진다.\n  - 공개키는 이름에서 알 수 있듯이 누구나 가질 수 있다. 대신, 개인키는 서버만이 가지고 있다.\n- 키가 노출되더라도 비교적 안전하지만, 연산 속도가 느리다.\n\n우리가 네이버에서부터 정보를 받았을 때, 이게 진짜 네이버에서 온 정보인지 어떻게 알 수 있을까?\n\n1. 네이버에서 우리에게 보내는 정보 중 일부가 네이버의 개인키로 암호화되어 있다.\n2. 네이버의 개인키로 암호화된 정보를 복호화할 수 있는 것은 우리가 가진 네이버의 공개키뿐이다.\n3. **만약 우리가 가진 네이버의 공개키로 온전히 복호화할 수 있다면, 그것은 네이버에서 온 정보일 것이다.**\n\n이 예시는 단순히 인증을 이해하기 위한 예시이며, 비대칭키 암호화를 사용하면 이렇게 인증을 할 수 있다는 것만 확인한다. 실제로 서버의 인증은 이후에 설명할 SSL 인증서를 통해 진행된다.\n\n## SSL 인증서\n\nSSL 인증서는 클라이언트와 서버 간의 통신을 제3자가 보증해주는 전자화된 문서이다. 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달한다. 클라이언트는 이 인증서가 신뢰할만한 것인지 검증한 후 다음 절차를 진행한다.\n\n이 SSL 인증서를 통해 앞서 언급한 HTTP의 보안 문제를 해결한다. 즉, SSL 인증서의 기능은 크게 다음과 같다.\n\n1. 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장한다.\n2. SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.\n\n### CA(Certificate Authority)\n\n앞서 말했듯, 인증서의 역할 중 하나는 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장하는 것이다. 그럼 누가 보증을 해줄까? 이를 인증하는 공인된 민간 기업들이 있다. 이러한 기업들을 CA라고 한다. SSL을 통해 암호화된 통신을 제공하려는 서비스는 CA를 통해 인증서를 구입해야 한다.\n\n### SSL 인증서의 내용\n\n- **서비스의 정보** (인증서를 발급한 CA, 서비스의 도메인 등)\n  - 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지에 대한 내용\n- **서버 측의 공개키** (공개키의 내용, 공개키의 암호화 방법)\n  - 서버와 통신할 때 사용할 공개키와 그 공개키의 암호화 방법\n\n서비스의 도메인, 공개키와 같은 정보는 서비스가 CA로부터 인증서를 구입할 때 제출해야 한다. 이 내용들은 CA에 의해서 암호화되는데, 이때 사용하는 암호화 방식이 공개키(비대칭키) 방식이다. **CA는 자신의 CA 개인키를 이용해서 서비스에서 제출한 인증서를 서명한다.** CA의 개인키는 절대로 유출되어서는 안 된다. 그리고, 우리가 사용하는 브라우저에는 CA들의 목록과 그들의 공개키가 내장되어 있다.\n\n## SSL 인증서가 서비스를 보증하는 방법\n\n1. 웹 브라우저가 서버에 접속할 때 서버는 제일 먼저 클라이언트에게 인증서를 제공한다.\n2. 브라우저는 이 인증서를 발급한 CA가 자신이 내장한 CA의 리스트에 있는지를 확인한다.\n3. 확인 결과 서버에서 받은 인증서가 내장된 CA 리스트에 포함되어 있다면, 해당 CA의 공개키를 이용해서 인증서를 복호화한다.\n4. **CA의 공개키를 이용해서 인증서를 복호화할 수 있다는 것은 이 인증서가 CA의 개인키에 의해 암호화된 것을 의미한다.**\n5. 해당 CA의 개인키를 가지고 있는 CA는 해당 CA밖에 없기 때문에, 서버가 제공한 인증서가 CA에 의해 올바르게 발급된 것이라는 것을 의미한다.\n6. 즉, CA에 의해 발급된 인증서라는 것은 접속한 사이트가 CA에 의해 검토되었다는 것을 의미하고, CA의 검토를 통과했다는 것은 해당 서비스가 신뢰할 수 있다는 것을 의미한다.\n\n이렇게 해서 인증서가 서버의 신뢰성을 제공하는 방법을 알아봤다. 그런데 의문점이 남는다. 인증서에 포함된 서버의 공개키는 어떤 용도로 사용될까?\n\n## SSL의 동작 방법\n\n비대칭키 암호화 방식만을 사용하면 컴퓨팅 파워가 많이 소모되기 때문에 SSL 인증서에서는 **대칭키 방식과 비대칭키 방식 모두를 사용**한다. 클라이언트와 서버가 주고받는 실제 정보는 대칭키 방식으로 암호화하고, 이 대칭키를 비대칭키 방식으로 암호화하여 클라이언트와 서버가 공유한다.\n\n- **실제 데이터 : 대칭키 방식**\n- **대칭키 방식의 키 : 비대칭키 방식**\n\n컴퓨터와 컴퓨터가 네트워크를 통해 통신을 할 때 내부적으로 3단계를 거친다.\n\n> Handshake → 전송 → 세션 종료\n\n이러한 과정에서 SSL이 어떻게 데이터를 암호화하여 전달하는지 알아보자.\n\n<figure>\n    <img src=\"img/http-vs-https-04.png\">\n    <figcaption>SSL Handshake는 TCP 레이어의 3-way Handshake 이후에 진행된다.</figcaption>\n</figure>\n\n1. **SSL Handshake**\n\n   1. Client Hello: 클라이언트가 서버에 접속하고, 클라이언트는 서버에 다음과 같은 정보를 전달한다.\n\n      - 클라이언트에서 생성한 랜덤 데이터\n      - 클라이언트가 지원하는 암호화 방식\n      - 세션 아이디: 이미 SSL Handshaking을 했다면 비용과 시간 절약을 위해 기존 세션을 재활용하는데 이를 위한 식별자 (이 과정에서는 크게 중요하지 않다.)\n\n   2. Server Hello: 서버는 Client Hello에 대한 응답으로 Server Hello 과정을 거치며, 클라이언트에 다음과 같은 정보를 전달한다.\n\n      - 서버에서 생성한 랜덤 데이터\n      - 서버가 지원하는 암호화 방식\n      - 인증서\n\n   3. 클라이언트는 서버에게서 받은 인증서가 CA가 발급한 것인지를 확인하기 위해 클라이언트에 내장된 CA 리스트를 확인한다.\n\n      만약, 그 리스트에 인증서가 없다면 사용자에게 경고 메시지를 출력한다. 인증서가 CA에 의해 발급된 것인지 확인하기 위해 내장된 CA의 공개키로 복호화를 시도한다. 만약 복호화에 성공하면 CA의 개인키로 암호화된 것이기 때문에 신뢰할 수 있다.\n\n      클라이언트는 자신이 생성한 랜덤 데이터와 서버에서 받은 랜덤 데이터를 조합하여 pre master secret이라는 키를 생성한다. 이 pre master secret이라는 키를 서버에도 전달해야 하는데, 이때 **공개키 방식**으로 암호화한다.\n\n      복호화된 인증서 안에는 서버가 생성한 공개키가 들어있다고 했었다. 클라이언트는 성공적으로 인증서를 복호화하면 서버 측에서 만든 공개키를 획득하게 된다. 클라이언트는 인증서에서 얻은 서버의 공개키로 pre master secret 값을 암호화하여 서버에 전달한다.\n\n   4. 서버는 그 공개키에 대한 개인키를 가지고 있기 때문에 pre master secret 값을 얻어낼 수 있다. 이제 클라이언트와 서버 모두 pre master secret 값을 공유하게 되었다. 클라이언트와 서버는 각각 일련의 과정을 통해 pre master secret에서 master secret 값을 만들어내고, 이 master secret으로 세션키를 생성한다. 이 세션키를 이용하여 서버와 클라이언트는 실제 데이터를 **대칭키 방식**으로 암호화하여 주고받는다.\n\n2. **전송(세션)**  \n   실제로 클라이언트와 서버가 데이터를 주고받는 단계이다. 이전 단계에서 얻은 세션키를 이용하여 대칭키 방식으로 데이터를 암호화하고 상대방에게 전달한다.\n3. **세션 종료**  \n   데이터 전송이 끝나면 서로에게 SSL 통신이 끝났음을 알린다. 세션 종료 후 세션키를 폐기하여 보안을 유지한다.\n\n## 참고 자료\n\n- https://www.youtube.com/watch?v=H6lpFRpyl14\n- https://www.youtube.com/watch?v=0cfUVrQW_yg&list=PLCZ-8rvakaqbplQZAoUku8uuxUgbLQm-1\n- https://opentutorials.org/course/228/4894\n- https://ko.gadget-info.com/difference-between-ssl\n"},{"excerpt":"프로그램이 자바 언어의 제약을 벗어난다면, JVM은 Exception으로 프로그램에게 에러를 발생시킨다. 예시로 정해진 배열의 범위를 벗어나 접근하는 경우가 있다. 또한, 프로그램은 를 사용해서 명시적으로 Exception을 발생시킬 수 있다. 이러한 자바의 Exception의 종류와 동작 방식 등에 대해 알아보자. Exception의 종류 Excepti…","fields":{"slug":"/java-exception/"},"frontmatter":{"date":"August 05, 2024","title":"[Java] Exception에 대한 고찰","tags":["Java","Exception","Checked Exception","Unchecked Exception"]},"rawMarkdownBody":"\n프로그램이 자바 언어의 제약을 벗어난다면, JVM은 Exception으로 프로그램에게 에러를 발생시킨다. 예시로 정해진 배열의 범위를 벗어나 접근하는 경우가 있다. 또한, 프로그램은 `throws`를 사용해서 명시적으로 Exception을 발생시킬 수 있다. 이러한 자바의 Exception의 종류와 동작 방식 등에 대해 알아보자.\n\n## Exception의 종류\n\n<figure>\n   <img src=\"img/java-exception-hierarchy.png\">\n   <figcaption>출처: https://www.javamex.com/tutorials/exceptions/exceptions_hierarchy.shtml</figcaption>\n</figure>\n\nException은 Throwable 클래스 혹은 그 서브클래스들의 인스턴스로 표현된다. 즉, Throwable 클래스와 그의 모든 서브클래스는 모두 예외를 나타내는 클래스들이다.\n\nThrowable 클래스의 직접 서브클래스(direct subclass)로는 Exception 클래스와 Error 클래스가 있다.\n\n- Exception 클래스는 일반적인 프로그램에서 복구를 시도할 수 있는 모든 예외의 상위 클래스이다. RuntimeException은 Exception 클래스의 직접 서브클래스이다.\n- Error 클래스는 일반적인 프로그램에서 복구가 기대되지 않는 모든 예외의 상위 클래스이다. 대표적인 예인 `OutOfMemoryError`, `StackOverflowError`와 같이 발생하더라도 개발자가 어찌할 수 없다.\n\nException은 크게 Unchecked Exception과 Checked Exception으로 나뉜다.\n\n- Unchecked Exception : Error 클래스, RuntimeException 클래스와 그의 서브 클래스를 말한다. 위 그림에서 빨간색에 해당하는 부분이다.\n- Checked Exception : Unchecked Exception(RuntimeException) 클래스가 아닌 모든 Exception의 서브 클래스를 말한다. 위 그림에서 빨간색이 아닌 파란색에 해당하는 부분이다.\n\n### Unchecked Exception\n\nUnchecked Exception은 <u>Error 클래스, RuntimeException 클래스와 그의 서브 클래스</u>를 말한다.\n\n컴파일 타임에 예외 처리를 위한 핸들러의 유무를 확인하지 않는다. Exception 처리가 강제되지 않아 개발자가 예외 처리 핸들러를 구현하지 않아도 된다. 물론, 원하는 경우에는 `catch`문을 사용해서 예상되는 RuntimeException 예외를 처리해줄 수 있다.\n\nError 클래스는 시스템 레벨의 심각한 문제를 나타내며, 일반적으로 개발자가 이를 처리할 수 있는 방법이 거의 없다. 예를 들어, `OutOfMemoryError`나 `StackOverflowError`와 같은 오류는 복구가 거의 불가능한 상황을 의미한다. 이러한 이유로 개발자는 애플리케이션 코드에서 `Error` 클래스에 대한 처리를 시도하지 않는 것이 일반적이다. 그렇기에 Unchecked Exception이라고 할 때는 RuntimeException과 그 하위 클래스를 주로 의미한다.\n\n### Checked Exception\n\nChecked Exception 클래스는 <u>Unchecked Exception 클래스가 아닌 모든 Exception 클래스</u>이다. 즉, RuntimeException 클래스 이외의 모든 Exception 클래스의 서브 클래스이다.\n\n자바는 Checked Exception에 대한 핸들러를 포함하도록 강제하여, 컴파일 타임에 Checked Exception에 대한 핸들러가 있는지 확인한다. 개발자는 예외 처리 핸들러를 반드시 포함해야 한다. `catch`문으로 처리하거나 `throws`를 이용해서 다른 곳에서 처리하도록 해야 한다. 이런 예외 처리 핸들러의 유무를 컴파일 타임에 확인함으로써 처리되지 않는 예외의 수를 줄일 수 있다.\n\n## 예외 처리 방식\n\n예외를 처리하는 방식에는 예외 복구, 예외처리 회피, 예외 전환 등 3가지 방법이 있다.\n\n### 예외 복구\n\n예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 방법이다.\n\n사용자가 특정 파일을 읽으려는데 파일이 없어 `IOException`이 발생하는 경우, 다른 파일을 선택하도록 유도하는 것으로 해결할 수 있다. 혹은 DB에 접속하는데에 실패하여 `SQLException`이 발생하는 경우, 여러 번 재시도하도록 할 수도 있다.\n\n```java\nint maxretry = MAX_RETRY;\nwhile (maxretry-- > 0) {\n   try {\n\n   } catch (SomeException e) {\n\n   } finally {\n\n   }\n}\nthrow new RetryFailedException();\n// 출처: 토비의 스프링 3.1 Vol.1 p286\n```\n\n이처럼 사용자에게는 원하는 것처럼 동작하지 않았기 때문에 예외 상황으로 비쳐지더라도 애플리케이션에서는 정상적인 흐름에 따라 진행되어야 한다. 물론, 단순히 에러 메시지를 사용자에게 보여주는 것은 예외 복구로 볼 수 없다.\n\n### 예외처리 회피\n\n자신이 예외 처리를 하지 않고 자신을 호출한 곳에서 예외 처리를 하도록 던져버리는 것이다. `throws`문을 활용해서 예외 발생시 바로 던져버리거나, `catch`문으로 일단은 잡아 로그를 남기고 다시 예외를 던진다.\n\n```java\npublic void add() throws SQLException {\n\n}\n```\n\n```java\npublic void add() throws SQLException {\n   try {\n\n   } catch (SQLException e) {\n      // 로그 출력\n      throw e;\n   }\n}\n// 출처: 토비의 스프링 3.1 Vol.1 p287\n```\n\n### 예외 전환\n\n예외처리 회피와 같이 `throws`를 이용해서 자신을 호출한 곳에서 예외를 처리하도록 한다. 하지만, 예외처리 회피와 달리 적절한 다른 예외로 바꾸어 던진다는 특징이 있다.\n\n예외 전환은 보통 두 가지 목적으로 사용된다.\n\n1. 발생한 예외를 그대로 던지는 것이 예외 상황을 적절히 설명하지 못하는 경우, 더 구체적인 의미를 가진 예외로 바꾸기 위해 사용한다.\n\n   예를 들어, 새로운 사용자를 등록하는데 이미 같은 아이디의 사용자가 존재하는 경우 `SQLException`이 발생한다. 하지만, 외부에 그대로 `SQLException`을 던져버리면 서비스 계층에서는 왜 `SQLException`이 발생했는지, 처리할 수 있는 것인지, 어떻게 처리할 지 등을 알 수 없다. 중복된 아이디에 대한 예외는 충분히 처리할 수 있기 때문에 적절한 예외로 바꾸어 던지는 것이 좋다.\n\n   ```java\n   public void add(User user) throws DuplicateUserIdException, SQLException {\n      try {\n\n      } catch (SQLException e) {\n         if (e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY) {\n            throw DuplicateUserIdException(e);\n         } else {\n            throw e;\n         }\n      }\n   }\n   // 출처: 토비의 스프링 3.1 Vol.1 p289\n   ```\n\n2. 예외 처리를 쉽고 단순하게 만들기 위해서 사용한다.\n\n   주로 예외 처리를 강제하는 Checked Exception에서 Unchecked Exception으로 바꾸는 경우에 사용한다. 예외 복구를 할 수 없거나 비즈니스적으로 의미가 없는 Checked Exception이라면 빠르게 RuntimeException으로 바꿔서 던지는 편이 좋다.\n\n발생한 예외를 다른 예외로 전환하는 경우, 원래 발생한 예외를 담아 중첩 예외를 만드는 것이 좋다. 중첩 예외는 `getCause()` 메소드를 이용해서 처음 발생한 예외가 무엇인지 파악할 수 있다.\n\n## JVM에서 예외를 처리하는 방법 (예외 발생 시 동작 방법)\n\n1.  예외가 발생하면 JVM은 Exception 객체를 생성한다.\n2.  Exception 객체가 생성되는 과정에서 `fillInStackTrace` 메소드가 호출된다.\n3.  `fillInStackTrace` 메소드 호출로 JVM은 예외 발생 시점의 호출 스택에서 각 스택 프레임 정보를 수집하고, 해당 정보가 Exception 객체의 스택 트레이스로 채워진다.\n\n    이때 수집되는 스택 프레임의 정보로는 클래스 이름, 메소드 이름, 파일 이름, 라인 번호 등등이 있다.\n\n    ```\n    // 스택 트레이스 예시\n    Exception in thread \"main\" java.lang.NullPointerException: Cannot load from object array because \"BOJ2563.papers\" is null\n      at BOJ2563.setUp(BOJ2563.java:45)\n      at BOJ2563.main(BOJ2563.java:15)\n    ```\n\n4.  호출된 메소드의 스택을 역순으로 올라가면서(unwinding the stack) Exception을 처리할 수 있는 예외 처리 핸들러가 있는지 확인한다.\n\n    <figure>\n       <img src=\"img/java-exception-stack-unwinding.png\">\n       <figcaption>출처: https://www.geeksforgeeks.org/exceptions-in-java/</figcaption>\n    </figure>\n\n5.  만약 예외 처리 핸들러를 발견하지 못하면, JVM은 해당 스레드를 종료시키며, 메인 스레드에서 예외가 처리되지 않으면 프로그램도 종료된다.\n\n## 예외 처리 비용\n\n일반적으로 예외 처리 비용은 비싸다고 알려져 있다. 그럼 왜 비싸고, 얼마나 비싼 것일까?\n\n우선, Baeldung의 [Performance Effects of Exceptions in Java](https://www.baeldung.com/java-exceptions-performance) 글에서 성능 측정을 한 결과는 다음과 같았다.\n\n```java\nBenchmark                                                 Mode  Cnt    Score   Error  Units\nExceptionBenchmark.createExceptionWithoutThrowingIt       avgt   10   16.605 ± 0.988  ms/op\nExceptionBenchmark.doNotThrowException                    avgt   10    0.047 ± 0.006  ms/op\nExceptionBenchmark.throwAndCatchException                 avgt   10   16.449 ± 0.304  ms/op\nExceptionBenchmark.throwExceptionAndUnwindStackTrace      avgt   10  326.560 ± 4.991  ms/op\nExceptionBenchmark.throwExceptionWithoutAddingStackTrace  avgt   10    1.185 ± 0.015  ms/op\n```\n\n위 글과 [The Exceptional Performance of Lil' Exception](https://shipilev.net/blog/2014/exceptional-performance/) 글에서의 결론은 다음과 같다.\n\n1. 예외가 발생하고 처리하는 과정은 일반적인 상황에 비해 더 많은 비용이 든다. 진정으로 예외가 필요한 곳에서만 예외 처리를 사용하자.\n2. try~catch문 자체는 성능에 큰 영향을 주지 않는다.\n3. 예외 처리 비용의 대부분은 **스택 트레이스를 구성하는 것**과 **스택을 역순으로 따라가며 예외 처리 핸들러를 찾는 과정**에서 발생한다.\n4. 스택 트레이스를 구성하는 데에 드는 비용은 Exception 객체가 생성되는 시점의 호출 스택 깊이에 비례한다.\n5. 예외를 캐싱하거나 `fillInStackTrace` 메소드를 오버라이드함으로써 최적화를 이룰 수 있다. 스택 트레이스의 정보가 생성되지 않을 수 있기 때문에 매우 특수한 경우에만 진행해야 한다.\n\n## (번외) Checked Exception에 대한 이슈\n\n개발자에게 예외 처리를 강제하는 Checked Exception에 대한 이슈가 있다.\n\n무조건 예상되는 예외를 처리하도록 하여 서비스의 안정성을 도모하고자 했지만, 이를 귀찮게 느낀 개발자들은 `catch`문으로 잡아만 두고 아무런 처리도 하지 않는다거나, 의미 없이 `throws Exception`만 한다는 것이다. Checked Exception이 처음 등장했을 때와 다르게 최근에는 Unchecked Exception을 사용하자는 의견이 많아지고 있다고 한다.\n\n더 자세한 내용은 아래 글을 참고하자.\n\n- [https://velog.io/@eastperson/Java의-Checked-Exception은-실수다-83omm70j](https://velog.io/@eastperson/Java%EC%9D%98-Checked-Exception%EC%9D%80-%EC%8B%A4%EC%88%98%EB%8B%A4-83omm70j)\n\n## 참고 자료\n\n- 토비의 스프링 3.1 Vol.1 4장\n- https://docs.oracle.com/javase/specs/jls/se22/jls22.pdf\n- https://docs.oracle.com/javase/specs/jvms/se22/jvms22.pdf\n- https://stackoverflow.com/questions/36343209/which-part-of-throwing-an-exception-is-expensive\n- https://www.baeldung.com/java-exceptions-performance\n- https://shipilev.net/blog/2014/exceptional-performance/\n- https://meetup.nhncloud.com/posts/47\n"},{"excerpt":"프로젝트 시작 계기 2023년 SSAFY를 다니면서 3번의 프로젝트를 진행했고, 2024년이 되면서 프로젝트보다는 알고리즘 문제 풀이나 CS 공부를 중심적으로 해야겠다고 생각했습니다. 이미 포트폴리오에 쓸 프로젝트를 완료했기에, 이제는 실질적인 취업 준비에 집중하고자 했습니다. 어떻게 하면 좋은 포트폴리오를 작성하고 취업을 잘할 수 있을까 고민하던 중, …","fields":{"slug":"/whiletrue-review/"},"frontmatter":{"date":"March 14, 2024","title":"whileTrue 프로젝트 후기","tags":["whileTrue","Chrome Extension","크롬 확장 프로그램","Notion API"]},"rawMarkdownBody":"\n<div align=\"center\">\n   <img src=\"img/whileTrue_icon.png\">\n</div>\n\n## 프로젝트 시작 계기\n\n2023년 SSAFY를 다니면서 3번의 프로젝트를 진행했고, 2024년이 되면서 프로젝트보다는 알고리즘 문제 풀이나 CS 공부를 중심적으로 해야겠다고 생각했습니다. 이미 포트폴리오에 쓸 프로젝트를 완료했기에, 이제는 실질적인 취업 준비에 집중하고자 했습니다.\n\n어떻게 하면 좋은 포트폴리오를 작성하고 취업을 잘할 수 있을까 고민하던 중, 블로그 제목에 끌려 이동욱 님의 글 하나를 보게 되었습니다. (https://jojoldu.tistory.com/763) 본인에게 필요한 것을 만들어보고 실제 출시도 해보면서 배운 점을 정리하는 것이 곧 포트폴리오가 된다는 내용이었습니다. 이 글을 보고 프로젝트를 하지 않겠다고 다짐했던 마음을 접고, 나에게 필요한 서비스가 무엇일지 고민하게 되었습니다.\n\n저는 알고리즘 문제를 풀 때, 다시 풀어보고 싶은 문제를 노션에 기록하고 있었습니다. 하지만, 문제 제목, 번호, URL 등등을 하나하나 직접 옮겨 적으려니 불편한 점들이 많았습니다. 또한, 저장된 문제들을 다시 풀고자 했을 때, 문제를 랜덤으로 뽑아줬으면 좋겠다고 생각했었습니다. 이 점을 개선하고자 whileTrue 프로젝트를 시작하게 되었습니다.\n\n## 시작하기 전, 고민한 부분\n\n기획 단계에서 확장 프로그램의 개발 언어, 프레임워크, 데이터베이스 선택 등 여러 가지를 고민하며 시작하게 되었습니다.\n\n### 자바스크립트 vs. 타입스크립트\n\n확장 프로그램의 개발 언어를 선택해야 했습니다. 자바스크립트로 진행할 경우, 이전에 사용해 본 경험이 있기 때문에 개발 진행이 상대적으로 더 빠를 것이라 생각되었습니다.\n\n그에 반해 타입스크립트로 진행하면 사용해 본 경험이 없기에 프로젝트 진행이 늦어질 것 같았습니다. 하지만 SSAFY 프로젝트의 프론트엔드 팀원들이 모두 타입스크립트를 사용하면서 궁금하기도 했고, 한번 경험해보고 싶다고 생각했기에 타입스크립트를 선택하게 되었습니다.\n\n### 리액트를 사용할 것인가?\n\n굳이 리액트를 사용하지 않고도 확장 프로그램을 개발할 수 있습니다. 리액트 역시 경험이 없기 때문에 선택하는 데에 고민이 되었습니다.\n\n리액트를 선택하면 다음과 같은 이점이 있었기에 고민이 되었고 결국 리액트를 선택하게 되었습니다.\n\n1. 보일러 플레이트가 있다.\n\n   구글이나 GitHub에 검색하시면 크롬 확장 프로그램 개발을 위한 리액트 보일러 플레이트를 여럿 보실 수 있습니다. 이를 활용하여 확장 프로그램 구조 조금 더 쉽게 파악을 할 수 있었고 코드 관리를 더 잘할 수 있을 것 같았습니다.\n\n2. 화면 디자인이 더 수월하지 않을까? (추측)\n\n   아무래도 리액트는 프론트엔드 라이브러리다 보니 화면을 디자인하고 다루는데 더 수월할 것 같다는 생각했습니다.\n\n3. 한번 해볼까?\n\n   SSAFY에서 진행한 3번의 프로젝트 모두 자바 스프링 백엔드 역할을 맡았습니다. 리액트를 사용해 본 적이 없었기에 이번 기회에 한번 써보고자 했습니다.\n\n### 어떤 데이터베이스를 사용할 것인가?\n\n처음에는 노션 데이터베이스를 활용하고자 했으나 진행하면서 꼭 노션이어야 하는 의문이 들었습니다. 노션 API를 다루기도 쉽지 않았고, 다시 풀고 싶은 문제를 저장하고 랜덤으로 추출하는 것이 중요하지 노션이어야 할 필요가 있을까라는 생각이 들었습니다. 더욱이 사용자가 데이터베이스 칼럼을 조작하지 못하기에 에러 핸들링이 간단해지는 이점도 있었습니다.\n\n하지만, 결국 다시 노션을 선택하게 되었습니다. 사용자들이 자신이 저장한 모든 문제를 볼 수 있어야 한다고 생각했습니다. 단순히 저장하고 하나씩 추출하는 것을 넘어 사용자들이 지금까지 쌓아온 문제들을 보는 것도 의미가 있을 것이라 판단했습니다. 모든 문제를 보여주는 것은 노션이 아니어도 가능하겠지만, 노션을 활용하는 것이 사용자들에게 색다른 경험을 제공하고 또 웹페이지에서 보는 것보다는 자신의 노션에서 보는 게 접근성이 좋을 것이라 생각했습니다.\n\n## 발생한 문제와 해결 방법\n\n### 노션 API는 CORS를 지원하지 않는다.\n\n프로젝트 초반에는 단순 확장 프로그램 단독으로 동작하는 것으로 구상했습니다. 하지만, 확장 프로그램에서 직접 노션 API를 사용하려고 하니 CORS 에러가 발생했습니다. 구글링을 통해 노션 API는 CORS를 지원하지 않는다는 것을 알게 되었습니다.\n\n![출처: https://medium.com/hcleedev/web-same-origin-policy%EC%99%80-cors-%EC%97%90%EB%9F%AC-%EA%B7%B8%EB%A6%AC%EA%B3%A0-preflight-8e8ce5375ff3](img/notion-api-cors.webp)\n\n노션 API의 CORS 문제로 인해 백엔드 서버를 구축해야 했고, 이로 인해 프로젝트의 규모가 예상보다 커지게 되었습니다.\n\n### 자바에서 JSON을 다루기가 만만치 않다.\n\n![초기 다이어그램: Spring 서버에서 모든 역할을 맡는다.](img/diagram1.jpg)\n\n초기 다이어그램은 위와 같습니다. 지금까지 스프링 부트로 백엔드 프로젝트를 진행해 왔기에 큰 고민 없이 스프링을 선택했습니다. 하나의 스프링 서버에서 인증, 인가를 포함한 비즈니스 로직 처리, 데이터베이스 접근과 노션 API와의 통신 등등을 담당했습니다.\n\n그러나 노션 API를 자바에서 사용하는데 불편함이 굉장히 많았습니다. JSON 형식으로 통신을 하는데 일일이 DTO를 만들어야 했고, 또 JSON의 깊이가 깊어 값을 받아오더라도 사용하는 데에 불편함이 많았습니다. 가장 큰 문제는 노션 API에서 반환되는 JSON의 키 값들이 고정되어 있지 않다는 것입니다.\n\n![number 타입 반환값](img/number-type-response.png)\n![title 타입 반환값](img/title-type-response.png)\n\n스프링에서 노션을 사용한 모든 DTO를 만드는 등의 작업은 마쳤지만, 이후 이 코드를 계속 사용하고 유지보수하기에는 어려울 것 같았습니다. 실제로 개발 도중, “난이도” 칼럼도 같이 저장해 달라는 요구 사항을 받고, 노션 API를 사용하는 부분을 수정해야 했는데 코드가 너무 복잡했고 큰 스트레스로 다가왔습니다. 결국 노션 API 사용하기 위한 Express 서버를 도입하기로 했습니다.\n\n![최종 다이어그램: Express 서버에서 Notion API를 다룬다.](img/diagram2.jpg)\n\n최종적인 시스템 아키텍처는 위와 같습니다. 자바스크립트(타입스크립트)를 활용하면 쉽게 JSON를 다룰 수 있기에 보다 편리하게 노션 API를 다룰 수 있었습니다. 비록 관리해야 하는 프로젝트가 총 3개(확장 프로그램, 스프링 백엔드, Express 백엔드)가 되었지만, 자바로 변화무쌍한 JSON 객체들을 다루지 않아도 된다는 이점이 더 크게 느껴졌습니다.\n\n이제 스프링 서버에서는 인증, 인가와 비즈니스 로직, 데이터베이스 접근의 역할을 맡게 되었고, 노션과 통신하는 부분은 Express 서버에서 맡게 되었습니다.\n\n### 어떻게 문제를 랜덤으로 뽑지?\n\n노션 API에는 데이터베이스에서 랜덤으로 뽑아주는 API가 없습니다. 처음에는 직접 데이터베이스에서 랜덤으로 선택해서 가져오는 방식으로 개발을 진행했습니다. 검색해 보시면 노션 데이터베이스에서 랜덤 값을 생성하는 방법들이 나옵니다. Formula 칼럼을 추가하여 랜덤 값을 생성하는 식을 넣으면 주기적으로 각 칼럼의 값이 랜덤값이 생성됩니다. (참고: https://medium.com/@andrewwongai/how-to-make-a-random-shuffle-gallery-view-in-notion-c1faf915c285)\n\n![Formula 칼럼을 활용해서 랜덤값을 생성할 수 있다.](img/random-column.webp)\n\n이를 활용하여 이 값으로 정렬한 후, 첫 번째 값을 반환하는 방법으로 구현했었습니다. 하지만, 사용자 경험 차원에서는 별로 좋지 않겠다는 생각을 했습니다. 사용자 입장에서는 필요 없는 정보인데 사용자의 노션에 있는 것이 보기 좋지 않을 것 같았습니다. 그리고 사용자가 기존 자신의 데이터베이스를 사용하는 경우에는 사용자가 직접 칼럼과 랜덤값을 생성하는 식을 넣어줘야 합니다. 랜덤값 칼럼이 없는 경우도 따로 에러 핸들링을 해야 했기 때문에 다른 방식을 택하게 되었습니다.\n\n그래서 현재 구현된 방식은 모든 문제를 가져와서 그중 랜덤 인덱스의 문제를 가져오는 방식입니다. 이로 인해 사용자 입장에서는 필요 없는 랜덤값 칼럼을 유지할 필요가 없어지고, 제 입장에서도 에러 핸들링을 하지 않아도 되어 관리하기 편해졌습니다. 랜덤 추출할 때마다 노션에서 모든 문제를 가져오는 것은 코스트가 많이 들 것이라 사용자의 로컬에 문제 리스트를 모두 저장하고 로컬에서 추출하는 방식으로 구현했습니다.\n\n## 남아있는 숙제\n\n1. 스프링 서버 재고\n\n   이쯤 되니 굳이 스프링 서버가 있어야 하나라는 생각이 듭니다. 아직은 Express에 자세히 알지 못해 스프링 서버를 대체할 수 없지만, 이후 Express에 대해 좀 더 공부를 하고 스프링 서버를 대체하지 않을까 싶습니다.\n\n2. 에러 핸들링\n\n   데이터베이스 공유와 같은 필수적인 에러 핸들링은 구현되어 있으나 이외는 아직 러프하게 되어있습니다. 이 부분을 더 세분화하여 사용자에게 더 자세히 에러를 알려주는 방식으로 진행할 것 같습니다.\n\n3. 비용\n\n   이건 아마 해결하지 못할 숙제일 듯합니다. 프로젝트를 오래 유지하기 위해 처음에는 비용이 발생하지 않는 방법으로 진행하려고 했습니다. 이런 이유로 확장 프로그램으로만 동작하는 방식으로 시작했습니다. 하지만 결국 AWS EC2, RDS, Codedeploy 등까지 사용하면서 비용이 발생하게 되었습니다. 프로젝트를 계속 유지시키기 위해서는 비용을 최소화해야 하기에 계속 고민할 것 같습니다.\n\n## 배우고 느낀 점\n\n1. 타입스크립트와 리액트\n\n   타입스크립트에서는 자바스크립트처럼 유연하게 코딩하면서도, 자바처럼 정적 타입 검사를 통해 코드 오류를 사전에 방지할 수 있어 안정성이 높다는 느낌을 받았습니다. 필요한 부분에서는 객체 interface나 type을 지정해 주어 사용할 때 내부 값들의 접근이 쉬웠습니다. interface나 type이 복잡한 경우에는 `any`를 써서 회피할 수 있는 것도 사용하는 데에 편리했습니다. 물론 깊게 써보지는 않았지만, 자바스크립트보다는 타입스크립트를 쓰는 게 더 도움 되지 않을까 싶습니다.\n\n   리액트를 사용하면서 리액트로 시작하기 잘했다는 생각을 했습니다. 개발하다 보니 꽤 많은 화면을 만들고 조건부 랜더링을 해야 했습니다. 단순 HTML로 다뤘으면 중복되는 내용도 많고 로직을 다루기도 쉽지 않았을 것 같습니다. 이번 개발에 필요한 리액트 개발 방법만 익혀 사용했기에 제대로 알지는 못하지만, 화면별로 분리하고 관리하기 편하다고 느꼈습니다.\n\n2. 공식 문서와 친해졌다.\n\n   이번 프로젝트를 진행하면서 크롬 개발자 문서와 노션 개발자 문서 참고를 많이 했습니다. 이전에는 공식 문서를 봐야 된다는 것을 알아도 가독성이 좋지 않다는 이유로 계속 기피했습니다. 하지만, 크롬 개발자 문서나 노션 API 문서는 정리도 잘 되어있기도 했고 사용한 레퍼런스도 많지 않아 공식 문서를 계속 참고했습니다. 이번 기회를 통해 공식 문서와 친해지지 않았나 생각합니다.\n\n3. 개발을 들어가기 전에 사전 조사를 자세히 해야겠다.\n\n   발생한 문제에서 말한 것처럼 진행하면서 아키텍처나 구현 방식을 여러 번 갈아엎었습니다. 단순 확장 프로그램만 개발한다는 첫 구상에서 백엔드, 데이터베이스, 서버, CI/CD까지 규모가 매우 커졌습니다. 물론 왕도로만 갈 수는 없겠지만, 그래도 사전에 알아보고 어느 정도 구상을 해봤으면 시간을 더 많이 아낄 수 있지 않았을까 하는 아쉬움이 남습니다.\n\n4. 실제 사용자를 받는다는 두려움\n\n   프로젝트를 단순히 개발하고 끝내는 것이 아니라, 실제 사용자들이 내 서비스를 사용한다는 생각에 막연한 두려움과 더 잘 만들어야 한다는 책임감을 느꼈습니다. 아직도 이런 마음이 없는 것은 아니지만, 개선해 나가면서 성장하는 것이고 또, 오픈 소스로 다 같이 만들어나가는 것이라 생각하며 완성했습니다. 그리고 안정적인 서비스를 만들기 위해 공부를 많이 해야겠다는 다짐하게 됐습니다.\n\n5. SSAFY를 통해 성장함을 느낌\n\n   사실 백엔드 기술 스택에 꽤 여러 개가 사용되었습니다. AWS의 EC2, RDS, Codedeploy, GitHub Actions, Docker, Spring, Express 등등을 도입했습니다. SSAFY의 프로젝트를 통해 경험을 이미 해보았고 사용 방법들을 알고 있었기에 큰 진입 장벽, 고민 없이 도입할 수 있었던 것 같습니다.\n\n6. 출시될 때의 뿌듯함\n\n   초반에 개발을 시작하면서 제대로 완성할 수 있을까라는 의구심이 들었습니다. 개발을 하면서도 몇 번의 큰 문제가 발생할 때마다 포기하고 싶다, 괜히 시작했나라는 생각이 들었습니다. 그래도 차근차근 하나씩 해결해나가다 보니 완성시킬 수 있었습니다. 그리고 크롬 웹 스토어의 승인을 받고 정식 출시가 되었을 때 굉장히 뿌듯했습니다.\n\n## 글을 마무리하며…\n\n앞으로 조금씩 프로젝트를 개선해 나갈 생각입니다. 상반기 채용 공고들이 나오고 있어서 큰 변화를 주지는 못하겠지만, 에러 수정 등은 꾸준히 할 예정입니다.\n\n마지막으로 프로젝트를 진행하는 데에 도움을 주신 분들께 감사 인사를 남기고 마무리하겠습니다. 먼저, ‘프로젝트는 이제 그만’이라는 닫힌 생각을 다시 열게끔 인사이트를 주신 이동욱 님께 감사드립니다. 덕분에 프로젝트를 시작할 수 있었습니다. 프로젝트에 “whileTrue”라는 이름을 붙여주시고, 페르소나가 되어주신 심부부 님, 적극적으로 의견을 내주시고 프로젝트를 지속할 수 있도록 응원해 주신 햄 님, 그리고 고민이 생기거나 결정 사항이 생길 때마다 고민 들어주시고 의견 주신 변 님까지 모두들 감사합니다.\n\n## 관련 링크\n\n- [GitHub](https://github.com/modisfive/whileTrue)\n- [크롬 웹 스토어](https://chromewebstore.google.com/detail/whiletrue/ockglcdfpkebaiaaocinjdcpiieceocn)\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}