{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"N+1 문제가 뭘까? 하나의 엔티티 전체를 조회하면서 그와 연관된 다른 엔티티를 조회할 때, 여러 번의 쿼리가 발생하는 문제입니다. 예를 들어, Team 엔티티와 Member 엔티티 사이에 다음과 같이 1:N(일대다)의 관계가 있다고 해보겠습니다.  그리고 각각의 엔티티는 다음과 같이 정의되어 있습니다. 총 3개의 팀이 있고, 각 팀에는 3명의 멤버가 있…","fields":{"slug":"/2/"},"frontmatter":{"date":"September 30, 2023","title":"[JPA] N+1 문제와 해결법","tags":["Spring","JPA","N+1"]},"rawMarkdownBody":"\n## N+1 문제가 뭘까?\n\n하나의 엔티티 전체를 조회하면서 그와 연관된 다른 엔티티를 조회할 때, 여러 번의 쿼리가 발생하는 문제입니다. 예를 들어, Team 엔티티와 Member 엔티티 사이에 다음과 같이 1:N(일대다)의 관계가 있다고 해보겠습니다.\n\n![](1.png)\n\n그리고 각각의 엔티티는 다음과 같이 정의되어 있습니다.\n\n```java\n@Getter\n@Entity\n@NoArgsConstructor\n@Builder\n@AllArgsConstructor\npublic class Member {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"member_id\")\n    private Long id;\n\n    private String name;\n\n    @ManyToOne\n    @JoinColumn(name = \"team_id\")\n    private Team team;\n\n    public void joinNewTeam(Team team) {\n        this.team = team;\n    }\n\n}\n```\n\n```java\n@Getter\n@Entity\n@NoArgsConstructor\npublic class Team {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"team_id\")\n    private Long id;\n\n    private String name;\n\n    @OneToMany(mappedBy = \"team\", cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    private List<Member> memberList = new ArrayList<>();\n\n    @Builder\n    public Team(Long id, String name, List<Member> memberList) {\n        this.id = id;\n        this.name = name;\n        if (memberList != null) {\n            this.memberList = memberList;\n        }\n    }\n\n    public void addNewMember(Member member) {\n        this.memberList.add(member);\n        member.joinNewTeam(this);\n    }\n}\n```\n\n총 3개의 팀이 있고, 각 팀에는 3명의 멤버가 있습니다.\n\n```java\n@BeforeEach\npublic void setup() {\n    List<Team> teamList = new ArrayList<>();\n\n    for (int i = 0; i < 3; i++) {\n        Team team = Team.builder().name(\"팀 \" + i).build();\n\n        for (int j = 0; j < 3; j++) {\n            team.addNewMember(Member.builder().name(\"멤버 \" + i + j).build());\n        }\n\n        teamList.add(team);\n        teamRepository.saveAll(teamList);\n    }\n}\n```\n\n```java\n@Service\n@RequiredArgsConstructor\npublic class TeamService {\n\n    private final TeamRepository teamRepository;\n\n    @Transactional\n    public List<String> findAllMemberNameFromAllTeam() {\n        System.out.println(\"\\n========== 모든 팀 조회 ==========\");\n        List<Team> teamList = teamRepository.findAll();\n\n        return findAllMemberName(teamList);\n    }\n\n    private List<String> findAllMemberName(List<Team> teamList) {\n        System.out.println(\"\\n========== 각 팀의 멤버 조회 ==========\");\n\n        List<String> nameList = new ArrayList<>();\n        for (Team team : teamList) {\n            nameList.addAll(team.getMemberList().stream().map(Member::getName).toList());\n        }\n        return nameList;\n    }\n}\n```\n\n우리는 모든 팀을 조회하고 각 팀에 속해 있는 모든 멤버들의 이름을 가져오고 싶습니다. 이것을 하나의 쿼리로 처리하고 싶지만 실제 실행된 쿼리를 보면 여러 쿼리가 동작한다는 것을 알 수 있는데, 이것이 N+1 문제입니다.\n\n![](2.png)\n\n처음에 모든 팀을 가져오는 쿼리가 실행되고(1), 총 N개의 팀을 가져오게 됩니다. 그리고 각 팀의 멤버들에 접근해야 하기 때문에 또 다시 각 팀에 대해서 쿼리가 실행됩니다.(N)\n\n우리의 예제에서는 총 3개의 팀이 있기 때문에, 모든 팀을 조회하는 쿼리 1개와 3개의 각 팀의 멤버들에 접근하는 쿼리 3개가 실행되는 것을 볼 수 있습니다.\n\n## 무엇이 문제인데?\n\n우리는 각 팀에 속해 있는 모든 멤버들의 이름을 가져오고 싶습니다. 하지만 기존의 방식대로 하면 팀들을 조회하는 쿼리와 각 팀의 멤버들을 조회하는 쿼리가 따로 나가기 때문에 문제가 됩니다. 위에서 든 예시에서는 팀의 수가 매우 적기 때문에 추가적으로 실행되는 쿼리의 수가 적지만, 만약 팀의 수가 매우 많은 경우에는 팀의 수만큼 쿼리가 실행되기 때문에 성능에 큰 문제가 될 수 있습니다.\n\n따라서, 쿼리가 따로 실행되는 것이 아니라 한 번의 쿼리로 팀의 정보와 각 팀들의 정보를 가져오는 방법이 없는지 고민해보아야 합니다.\n\n## 왜 발생할까?\n\nN+1 문제가 왜 발생할까요? 그럼 반대로 생각해보겠습니다. N+1 문제가 발생하지 않도록 하려면 JPA가 어떻게 동작해야 할까요?\n\n모든 팀의 조회하는 쿼리와 함께 각 팀에 연관된 엔티티도 모두 조회하는 쿼리도 포함시켜서 한 번에 처리하고 전부 영속성 컨텍스트에 저장해야 합니다. 하지만, JPA가 기본적으로 이렇게 동작한다면 이 역시도 큰 문제가 될 것입니다.\n\n## FetchType.LAZY(지연 로딩)을 하면 괜찮지 않을까?\n\nJpaRepository의 메소드들은 JPQL로 실행되는데, JPQL은 Fetch 전략과 상관없이 일단 SQL로 변환되어 실행됩니다. 즉시 로딩, 지연 로딩 같은 글로벌 Fetch 전략과 상관없이 일단 모든 팀의 정보를 가져옵니다. 그 이후에 JPA는 엔티티에 설정된 Fetch 전략에 따라 연관된 엔티티를 바로 가져올지 말지 판단합니다.\n\n따라서, N+1 문제는 즉시 로딩이나 지연 로딩과 상관 없습니다. `FetchType.EAGER`인 경우에는 모든 팀을 조회하는 쿼리가 수행된 이후에 추가적인 쿼리도 바로 연이어 나가고, `FetchType.LAZY`인 경우에는 추가 쿼리가 바로 나가지는 않지만, 각 팀에 접근해서 멤버들을 조회할 때 쿼리가 나가게 됩니다.\n\n즉, 즉시 로딩이나 지연 로딩은 연관된 엔티티를 가져오는 쿼리가 언제 나가느냐에 차이가 있을 뿐, 결과적으로 둘 다 추가적인 쿼리를 통해서 연관된 엔티티를 가져옵니다.\n\n## 그럼 어떻게 해결하지?\n\n대표적인 해결 방법으로는 Fetch Join, @EntityGraph, BatchSize를 이용하는 방법이 있습니다.\n\n## Fetch Join\n\n- 코드 블럭으로 보기\n  ```java\n  @Query(\"select t from Team t join fetch t.memberList\")\n  List<Team> findAllFetchJoin();\n  ```\n  ```sql\n  select\n      team0_.team_id as team_id1_1_0_,\n      memberlist1_.member_id as member_i1_0_1_,\n      team0_.name as name2_1_0_,\n      memberlist1_.name as name2_0_1_,\n      memberlist1_.team_id as team_id3_0_1_,\n      memberlist1_.team_id as team_id3_0_0__,\n      memberlist1_.member_id as member_i1_0_0__\n  from\n      team team0_\n  inner join\n      member memberlist1_\n          on team0_.team_id=memberlist1_.team_id\n  ```\n\nFetch Join은 일반 SQL에서 제공하는 기능이 아닌, JPQL에서 성능 최적화를 위해 제공하는 기능입니다. Fetch Join을 사용하면 연관된 엔티티나 컬렉션을 한 번의 SQL 쿼리로 가져올 수 있습니다.\n\n![](3.png)\n\n![](4.png)\n\n그리고 위 사진에서 볼 수 있다시피 Fetch Join은 Inner Join으로 수행됩니다.\n\n## @EntityGraph\n\n- 코드 블럭으로 보기\n  ```java\n  @EntityGraph(attributePaths = \"memberList\")\n  @Query(\"select t from Team t\")\n  List<Team> findAllEntityGraph();\n  ```\n  ```sql\n  select\n      team0_.team_id as team_id1_1_0_,\n      memberlist1_.member_id as member_i1_0_1_,\n      team0_.name as name2_1_0_,\n      memberlist1_.name as name2_0_1_,\n      memberlist1_.team_id as team_id3_0_1_,\n      memberlist1_.team_id as team_id3_0_0__,\n      memberlist1_.member_id as member_i1_0_0__\n  from\n      team team0_\n  left outer join\n      member memberlist1_\n          on team0_.team_id=memberlist1_.team_id\n  ```\n\n@EntityGraph의 `attributePaths`에 쿼리 수행 시에 같이 가져올 필드명을 지정하면 한 번에 모두 가져오게 됩니다.\n\n![](5.png)\n\n![](6.png)\n\n주목할 점은 Fetch Join은 Inner Join으로 수행되는 반면, @EntityGraph는 Outer Join으로 수행된다는 것입니다.\n\n## Fetch Join과 @EntityGraph의 문제점\n\n1. 단순 Fetch Join만을 사용하면 카테시안 곱이 발생하기 때문에 일대다 관계의 일(1) 부분에서 중복 발생하게 됩니다.\n\n   ```java\n   @Test\n   void joinFetch() {\n\n       System.out.println(\"\\n========== Fetch Join 테스트 ==========\");\n       System.out.println(\"\\n========== 모든 팀 조회 ==========\");\n\n       List<Team> allTeams = teamRepository.findAllFetchJoin();\n\n       System.out.println(\"\\n========== 모든 팀 조회 끝 ==========\");\n       System.out.println(\"\\n========== 각 팀의 멤버 조회 ==========\");\n\n       List<String> allMemberNames = new ArrayList<>();\n       for (Team team : allTeams) {\n           System.out.println(team.getName());\n           for (Member member : team.getMemberList()) {\n               System.out.println(member.getName());\n               allMemberNames.add(member.getName());\n           }\n       }\n\n       System.out.println(\"\\n========== 각 팀의 멤버 조회 끝 ==========\");\n       System.out.println(\"allTeams = \" + allTeams.size());\n       System.out.println(\"allMemberNames = \" + allMemberNames.size());\n\n   }\n   ```\n\n   ![](7.png)\n\n   ![](8.png)\n\n   이를 해결하기 위해서는 JPQL의 DISTINCT 키워드를 사용하거나 Set 컬렉션을 이용해서 중복되는 값을 제거해야 합니다.\n\n   ```java\n   @Query(\"select distinct t from Team t join fetch t.memberList\")\n   List<Team> findAllDistinctFetchJoin();\n   ```\n\n   ```java\n   @EntityGraph(attributePaths = \"memberList\")\n   @Query(\"select distinct t from Team t\")\n   List<Team> findAllDistinctEntityGraph();\n   ```\n\n   ```java\n   // Set을 이용하는 경우\n\n   @Query(\"select t from Team t join fetch t.memberList\")\n   Set<Team> findAllFetchJoinBySet();\n   ```\n\n2. 페이징 처리가 어렵습니다. Fetch Join과 @EntityGraph에서는 페이징 API를 지원하지 않기 때문에 페이징 처리를 할 수 없습니다.\n\n## BatchSize\n\nBatchSize 값을 설정하면 한 번의 쿼리로 연관된 데이터 몇 개를 가져올 지를 지정할 수 있습니다. 예를 들어 70개의 가져올 데이터가 있고 BatchSize가 30인 경우, 총 3번의 쿼리로 30개, 30개, 10개씩 가져오게 됩니다. 하나의 쿼리로 모든 데이터를 조회할 수는 없지만(전체 데이터 수가 BatchSize보다 큰 경우), 기존의 N+1 문제에서 발생한 쿼리 수보다는 적게 발생합니다.\n\n## 참고\n\n- [[블로그] JPA N+1 문제 및 해결방안 (향로 님)](https://jojoldu.tistory.com/165)\n- [[블로그] JPA N+1 발생 케이스와 해결책 (최진영 님)](https://brunch.co.kr/@jinyoungchoi95/2)\n- [[인프런 강의] 자바 ORM 표준 JPA 프로그래밍 - 기본편 (김영한 님)](https://www.inflearn.com/course/ORM-JPA-Basic)\n"},{"excerpt":"이 글은 자바 컬렉션 프레임워크(Java Collections Framework)에 포함된 여러 인터페이스와 클래스의 Javadoc 문서를 읽고 번역한 글입니다. 번역은 대부분 제가 직접 했고 일부 ChatGPT의 도움을 받았습니다. 의미를 구분하거나 분명히 해야 하는 경우에는 영문을 그대로 남겼습니다. 어색한 표현이나 수정해야 할 부분은 댓글로 남겨주시…","fields":{"slug":"/1/"},"frontmatter":{"date":"September 19, 2023","title":"[번역] Collection의 공식 문서 읽기","tags":["Java Collections Framework","Collection","JCF","자바","컬렉션","Javadoc","공식 문서"]},"rawMarkdownBody":"\n> 이 글은 자바 컬렉션 프레임워크(Java Collections Framework)에 포함된 여러 인터페이스와 클래스의 Javadoc 문서를 읽고 번역한 글입니다. 번역은 대부분 제가 직접 했고 일부 ChatGPT의 도움을 받았습니다. 의미를 구분하거나 분명히 해야 하는 경우에는 영문을 그대로 남겼습니다. 어색한 표현이나 수정해야 할 부분은 댓글로 남겨주시면 감사드리겠습니다.\n\n## Collection\n\n`Collection` 계층의 루트 인터페이스입니다. 컬렉션은 객체(컬렉션의 요소)의 집합을 표현합니다. 어떤 컬렉션은 중복된 요소를 허용하고, 어떤 컬렉션은 허용하지 않습니다. 어떤 컬렉션은 정렬되어 있고, 어떤 컬렉션은 정렬되어 있지 않습니다. JDK는 이 인터페이스의 직접적인 구현체를 제공하지 않습니다. `Set`이나 `List` 같은 조금 더 구체적인 서브 인터페이스의 구현체를 제공합니다. 이 인터페이스는 일반적으로 컬렉션은 전달하고 일관되게 조작할 수 있도록 사용됩니다.\n\n`Bags`나 `multisets` (중복된 요소를 포함하는 정렬되지 않은 컬렉션)은 이 인터페이스를 직접적으로 구현해야 합니다.\n\n모든 범용적인 컬렉션 구현 클래스(일반적으로 `Collection`의 서브 인터페이스 중 하나를 통해 `Collection`을 구현합니다.)는 두 개의 “표준” 생성자를 제공해야 합니다. 빈(empty) 컬렉션을 생성하는 void 생성자와 컬렉션 형식의 단일 인자를 받고 해당 인자의 요소와 동일한 요소를 가지는 새로운 컬렉션을 생성하는 생성자입니다. 사실, 후자의 생성자는 사용자가 모든 컬렉션을 복사하여 원하는 구현 타입과 동등한 컬렉션을 생성할 수 있도록 합니다. 이 컨벤션을 강요하는 방법은 없지만(인터페이스는 생성자를 가질 수 없기 때문에), Java 플랫폼 라이브러리의 모든 범용적인 Collection 구현체들은 이를 준수합니다.\n\n특정 메소드는 선택적으로 지정됩니다. 만약 구현체가 한 특정 메소드를 구현하지 않은 경우, 해당 메소드가 `UnsupportedOperationException`을 발생시키도록 정의해야 합니다. 이런 특정 메소드들은 컬렉션 인터페이스들의 메소드 명세에서 “optional operation”이라 표기되어 있습니다.\n\n일부 컬렉션 구현체들은 그들이 포함할 수 있는 요소들에 제한이 있습니다. 예를 들어, 어떤 구현체들은 `null` 요소를 금지하고, 어떤 구현체는 요소들의 타입에 제한이 있습니다. 부적격한 요소를 넣으려는 시도는 unchecked 예외, 보통 `NullPointerException`이나 `ClassCastException`을 발생시킵니다. 부적격한 요소의 존재를 쿼리하려는 시도는 예외를 발생시키거나 단순히 `false`를 반환합니다. 일부 구현체들은 행위 전에 금지시키거나 일부 구현체는 행위 후에 금지시킵니다. 보다 일반적으로, 부적격한 요소에 대한 작업을 시도하면 해당 작업의 완료로 인해 컬렉션에 자격이 없는 요소가 삽입되지 않을 경우 예외를 발생시키거나 구현에 따라 성공할 수 있습니다. 이러한 예외는 이 인터페이스 명세서에서 “optional\"으로 표시됩니다.\n\n동기화 전략은 각 컬렉션에 따라 다릅니다. 구현에서 더 강력한 보장이 제공되지 않는 경우, 다른 스레드에 의해 변형되는 컬렉션에 대한 어떤 메소드의 호출에서 정의되지 않은 동작이 발생할 수 있습니다. 이것은 직접적인 호출, 호출할 수 있는 메소드에게 컬렉션을 전달하는 것, 그리고 컬렉션을 검사하기 위해 존재하는 반복자(iterator)를 사용하는 것을 포함합니다.\n\nCollections Framework 인터페이스의 많은 메소드들은 `equals` 메소드에 의해 정의되어 있습니다. 예를 들어, `contains(Object o)` 메소드의 명세서에는 “이 컬렉션이 `(o==null ? e==null : e.equals(e))`를 만족하는 요소 `e`를 최소 하나를 포함해야 `true`를 반환한다”라고 나와있습니다. 이 명세가 `Collection.contains`를 `null`이 아닌 인자 `o`로 호출할 경우 `o.equals(e)`가 모든 요소 `e`에 대해 호출된다는 것으로 이해되서는 안 됩니다. `equals` 호출이 금지되고 예를 들어, 두 요소의 해시 코드를 먼저 비교하는 등의 방법으로 자유롭게 최적화를 할 수 있습니다. (`Object.hashCode()` 명세는 서로 다른 해시 코드를 가지는 두 객체는 다르다는 것을 보장합니다.) 보다 일반적으로, 여러 Collections Framework 인터페이스의 구현체는 구현자가 적절하다고 판단하는 경우에 기본 Object 메소드의 명시된 동작을 활용할 수 있습니다.\n\n직간접적으로 자기 자신을 포함하는 자기 참조 인스턴스에서 컬렉션을 재귀적으로 순회하는 일부 컬렉션 작업은 예외를 발생시킬 수 있습니다. 여기에는 `clone()`, `equals()`, `hashCode()`, `toString()` 메소드가 포함됩니다. 구현체는 선택적으로 자기 참조를 할 수 있지만, 현재 대부분의 구현체는 그렇지 않습니다.\n\n## View Collections\n\n대부분의 컬렉션들은 자신들이 포함하는 요소들의 저장 공간을 관리합니다. 이와 반대로, view 컬렉션들은 그들 스스로 요소를 관리하지 않고 대신 실제 요소를 저장하기 위해 backing 컬렉션에 의존합니다. view 컬렉션에 의해 관리되지 않는 동작들은 backing 컬렉션에게 위임됩니다. view 컬렉션의 예시로는 `Collections.checkedCollection`, `Collections.synchronizedCollection`, `Collections.unmodifiableCollection` 등의 메소드에 의해 반환되는 wrapper 컬렉션들이 있습니다. 또 다른 예로는 `List.subList`, `NavigableSet.subSet`, `Map.entrySet` 등으로 같은 요소의 다른 표현법을 제공하는 컬렉션이 있습니다. backing 컬렉션에 대한 모든 변경 사항은 view 컬렉션에서도 볼 수 있습니다. 마찬가지로, view 컬렉션에서 (변경이 허용된 경우) 수행된 모든 변경 사항은 backing 컬렉션에 저장됩니다. 비록 Iterator와 ListIterator의 인스턴스가 컬렉션은 아니지만, 그들 역시 backing 컬렉션으로의 변경 사항이 저장되는 것을 허용할 수 있고, 때때로 backing 컬렉션의 변경이 Iterator가 반복하는 동안 보일 수도 있습니다.\n\n## Unmodifiable Collections\n\n이 인터페이스의 특정 메소드들은 “파괴적”으로 간주되고 “mutator(변경자)”라고 불리는 점에서 그들은 그들이 동작하는 컬렉션에 포함된 객체들의 집합을 수정할 수 있습니다. 이 컬렉션 구현체가 동작을 구현하지 않으면 이 메소드들은 `UnsupportedOperationException`을 발생시키도록 명시될 수 있습니다. 이런 메소드들은 (필수는 아니지만) 호출이 컬렉션에 아무 영향을 주지 않은 경우, `UnsupportedOperationException`을 발생시켜야 합니다. 예를 들어, `add` 동작을 지원하지 않는 컬렉션에 대해서 생각해봅시다. 인자로 빈(empty) 컬렉션와 함께 이 컬렉션에서 `addAll` 메소드가 호출되면 어떤 일이 발생할까요? 요소를 추가하지 않는 경우, 영향을 주지 않기 때문에 이 컬렉션은 단순히 아무것도 하지 않고 예외를 발생시키지 않아도 괜찮습니다. 하지만 특정한 경우에만 예외를 발생시키는 것은 프로그래밍 오류를 유발할 수 있기 때문에, 이러한 경우에도 무조건 예외를 던지는 것이 권장됩니다.\n\nunmodifiable 컬렉션들은 모든 변경자(mutator) 메소드이 `UnsupportedOperationException`를 발생시키도록 명시되어 있습니다. 그러므로 이런 컬렉션은 그의 어떤 메소드를 통해서도 변경될 수 없습니다. 컬렉션이 적절하게 변경되지 않게 하기 위해서, 여기서 파생된 모든 view 컬렉션 역시 변경 불가능이어야만 합니다. 예를 들어 List가 변경 불가능하다면, `List.subList`로 반환되는 List 역시 변경 불가능해야 합니다.\n\nunmodifiable 컬렉션들이 꼭 immutable인 것은 아닙니다. 만약 포함된 요소가 mutable하다면, 전체 컬렉션이 unmodifiable일지라도 mutable합니다. (_의미를 분명히 하기 위해 영문 그대로 적었습니다._) 예를 들어, unmodifiable한 리스트 두 개가 mutable한 요소들을 포함한다고 합시다. 비록 두 리스트 모두 unmodifiable하더라도, 요소들이 mutated됨에 따라 `list1.equals(list2)`의 호출 결과가 달라질 수 있습니다. 하지만, 만약 unmodifiable한 컬렉션이 모두 immutable한 요소들을 가진다면, 이는 효과적으로 inmmutable합니다.\n\n## Unmodifiable View Collections\n\nunmodifiable view 컬렉션은 unmodifiable한 동시에 backing 컬렉션의 view입니다. 이들의 변경자(mutator) 메소드들은 `UnsupportedOperationException`을 던지는 반면(위에서 설명했듯), 읽기와 쿼리 메소드들은 backing 컬렉션에게 위임합니다. 이는 backing 컬렉션으로의 읽기 전용(read-only) 접근을 제공합니다. 이것은 구성 요소가 내부 컬렉션에 대한 읽기 액세스를 제공하면서 사용자가 이러한 컬렉션을 예상치 못하게 수정하는 것을 방지하는 데 유용합니다. unmodifiable view 컬렉션의 예로는 `Collections.unmodifiableCollection`, `Collections.unmodifialbeList`, 그리고 관련된 메소드들의 반환값이 있습니다.\n\nbacking 컬렉션의 수정은 여전히 가능하고, 만약 발생한다면 그들은 unmodifiable view를 통해 보일 것입니다. 그러므로 unmodifiable view 컬렉션은 꼭 immutable할 필요는 없습니다. 하지만 unmodifiable view의 backing 컬렉션이 사실상 immutable이 불가능하거나 backing 컬렉션에 대한 유일한 참조가 unmodifiable view를 통해서만 이루어진 경우, 해당 view는 사실상 변경 불가능하다고 할 수 있습니다.\n\n## Serializability of Collections\n\n컬렉션의 직렬성(Serializability of Collections)는 선택적입니다. 따라서 어떤 컬렉션 인터페이스도 `java.io.Serializable` 인터페이스를 구현하도록 선언되어 있지 않습니다. 하지만, 직렬성은 일반적으로 사용되는 것으로 간주되고, 따라서 대부분의 컬렉션 구현체들은 직렬적입니다(serializable).\n\npublic 클래스인 컬렉션 구현체(`ArrayList`나 `HashMap` 같은)는 실제로 직렬화 가능한 경우, `Serializable` 인터페이스를 구현하도록 선언되어 있습니다. unmodifiable 컬렉션 같은 컬렉션 구현체들은 public 클래스가 아닙니다. 이런 컬렉션의 직렬화는 그들을 생성하는 메소드의 명세나 다른 적절한 위치에 설명되어 있습니다. 컬렉션의 직렬성이 명세되지 않은 경우, 이러한 컬렉션의 직렬성은 보장되지 않습니다. 특히, 많은 view 컬렉션은 직렬적이지 않습니다.\n\n`Serializable` 인터페이스를 구현하는 컬렉션 구현체는 직렬적임이 보장되지 않습니다. 일반적으로, 컬렉션은 다른 타입의 요소를 포함하고, 일부 요소의 인스턴스들이 실제로 직렬적인지 전역적으로 판단하는 것은 불가능하기 때문입니다. 예를 들어, `E`가 `Serializable` 인터페이스를 구현하지 않고, 직렬적인 `Collection<E>`에 대해서 생각해봅시다. `E`의 직렬적인 서브 타입의 요소들만 포함하거나 빈 경우에만 이 컬렉션은 직렬적일 것입니다. 따라서 컬렉션은 조건부로 직렬화 가능하다고 말할 수 있으며, 컬렉션 전체의 직렬화 여부는 컬렉션 자체가 직렬화 가능하고 모든 포함된 요소도 직렬화 가능한지에 따라 달라집니다.\n\n추가적인 경우는 `SortedSet`과 `SortedMap`의 인스턴스에서 발생합니다. 이 컬렉션들은 집합 요소나 맵 키를 정렬하는 `Comparator`에 의해 생성됩니다. 이런 컬렉션은 주어진 Comparator가 직렬화 가능한 경우에만 직렬화가 가능합니다.\n\n## 속성과 메소드\n\n```java\npublic interface Collection<E> extends Iterable<E> {\n\n    // Query Operations\n\n    int size();\n    boolean isEmpty();\n    boolean contains(Object o);\n    Iterator<E> iterator();\n    Object[] toArray();\n    <T> T[] toArray(T[] a);\n    default <T> T[] toArray(IntFunction<T[]> generator) {\n        return toArray(generator.apply(0));\n    }\n\n    // Modification Operations\n\n    boolean add(E e);\n    boolean remove(Object o);\n\n    // Bulk Operations\n\n    boolean containsAll(Collection<?> c);\n    boolean addAll(Collection<? extends E> c);\n    boolean removeAll(Collection<?> c);\n    default boolean removeIf(Predicate<? super E> filter) {\n        Objects.requireNonNull(filter);\n        boolean removed = false;\n        final Iterator<E> each = iterator();\n        while (each.hasNext()) {\n            if (filter.test(each.next())) {\n                each.remove();\n                removed = true;\n            }\n        }\n        return removed;\n    }\n    boolean retainAll(Collection<?> c);\n    void clear();\n\n    // Comparison and hashing\n\n    boolean equals(Object o);\n    int hashCode();\n    @Override\n    default Spliterator<E> spliterator() {\n        return Spliterators.spliterator(this, 0);\n    }\n    default Stream<E> stream() {\n        return StreamSupport.stream(spliterator(), false);\n    }\n    default Stream<E> parallelStream() {\n        return StreamSupport.stream(spliterator(), true);\n    }\n}\n```\n\n## Query Operations\n\n#### `int size();`\n\n- 이 컬렉션에 있는 요소의 개수를 반환합니다. 만약 이 컬렉션이 `Integer.MAX_VALUE`보다 더 많이 가지고 있다면, `Integer.MAX_VALUE`를 반환합니다.\n- Returns: 이 컬렉션에 있는 요소의 개수\n\n#### `boolean isEmpty();`\n\n- 이 컬렉션이 아무런 요소도 가지고 있지 않은 경우, `true`를 반환합니다.\n- Returns: 이 컬렉션이 아무런 요소도 가지고 있지 않은 경우, `true`\n\n#### `boolean contains(Object o);`\n\n- 이 컬렉션이 특정 요소를 포함하는 경우, `true`를 반환합니다. 더 자세히로는, `Object.equals(o, e)`인 요소 `e`를 최소 하나 포함하는 경우에만 `true`를 반환합니다. (_iff_)\n- Params: `o` - 이 컬렉션에 대해 지정된 요소가 존재하는지 테스트하려는 요소\n- Returns: 이 컬렉션이 지정된 요소를 포함하는 경우, `true`\n- Throws\n  - `ClassCastException` - 이 컬렉션과 지정된 요소의 타입이 맞지 않은 경우\n  - `NullPointerException` - 특정 요소가 `null`이고 이 컬렉션이 `null`을 허용하지 않는 경우\n\n#### `Iterator<E> iterator();`\n\n- 이 컬렉션의 요소들을 순회하기 위한 반복자(iterator)를 반환합니다. (이 컬렉션이 요소의 반환 순서를 보장하는 클래스의 인스턴스가 아니라면) 요소가 반환되는 순서에 대한 보장은 없습니다.\n- Returns: 이 컬렉션의 요소들을 순회하는 반복자\n\n#### `Object[] toArray();`\n\n- 이 컬렉션의 모든 요소를 포함하는 배열을 반환합니다. 이 컬렉션의 반복자(iterator)가 요소의 반환 순서를 보장한다면, 이 메소드는 반드시 같은 순서로 요소들을 반환해야 합니다. 반환된 배열의 런타임 컴포넌트 타입은 `Object` 입니다.\n  반환된 배열은 안전하다는 점에서 이 컬렉션에 의해 유지되는 참조가 없습니다. (다시 말해서, 해당 메소드가 배열의 지원을 받더라도 이 메소드는 새로운 배열을 할당해야 한다.) 그러므로, 호출자(caller)는 반환된 메소드를 자유롭게 수정할 수 있습니다.\n- Returns: 이 컬렉션의 모든 요소를 포함하고, 런타임 컴포넌트 타입이 `Object`인 배열\n- API Note: 이 메소드는 array-based API와 collection-based API 사이에서 다리 역할을 합니다. 런타임 타입이 `Object[]`인 배열을 반환합니다. 존재하는 배열을 사용하기 위해서는 `toArray(T[])` 사용하고, 배열의 런타임 타입을 다루기 위해서는 `toArray(IntFunction)`을 사용하세요.\n\n#### `<T> T[] toArray(T[] a);`\n\n- 이 컬렉션의 모든 요소를 포함하는 배열을 반환합니다. 반환된 배열의 런타임 타입은 지정된 배열(파라미터)의 런타입 타입과 같습니다. 만약 컬렉션이 지정된 배열에 맞다면, 그 안에 반환됩니다. 그렇지 않다면, 주어진 배열의 런타임 타입과 이 컬렉션의 크기로 새로운 배열이 할당됩니다.\n  만약 이 컬렉션이 주어진 배열에 여분의 공간을 가지고 들어간다면 (즉, 배열의 요소 개수가 이 컬렉션보다 많다면), 컬렉션의 끝 바로 다음에 오는 배열 요소는 `null`로 설정됩니다. (이것은 이 컬렉션에 `null` 요소가 포함되어 있지 않다는 것을 호출자가 알고 있는 경우에만 이 컬렉션의 길이를 결정하는 데 유용합니다.)\n  이 컬렉션의 반복자(iterator)가 요소의 반환 순서를 보장한다면, 이 메소드는 반드시 같은 순서로 요소들을 반환해야 합니다.\n- Params: `a` - 이 컬렉션의 요소들을 저장하기 위한 배열이 충분히 크다면 이 배열을 사용하고, 그렇지 으면 같은 런타임 타입의 새로운 배열이 할당됨\n- Returns: 이 컬렉션의 모든 요소를 포함하는 배열\n- Throws:\n  - `ArrayStoreException` - 이 컬렉션의 어떤 요소의 런타임 타입이 주어진 배열의 런타임 컴포넌트 타입에 할당 가능하지 않은 경우\n  - `NullPointerException` - 만약 주어진 배열이 `null`인 경우\n- API Note: 이 메소드는 array-based API와 collection-based API 사이에서 다리 역할을 합니다. 이는 특정 환경 하에서 존재하는 배열이 재사용될 수 있게끔 합니다. 런타임 타입이 `Object[]`인 배열을 생성하기 위해서는 `toArray()`를 사용하고, 배열의 런타임 타입을 다루기 위해서는 `toArray(IntFunction)`을 사용하세요.\n  문자열만을 포함하는 컬렉션 `x`가 있다고 합시다. 아래에 주어진 코드는 이 컬렉션을 미리 할당된 String 배열에 넣는 데 사용될 수 있습니다.\n  `java\nString[] y = new String[SIZE];\n...\ny = x.toArray(y);\n`\n\n                컬렉션 `x`가 이미 존재하는 배열 `y`보다 더 많은 요소를 가지는 경우, 새로운 배열이 할당되고 반환되어, 반환된 값은 변수 `y`에 재할당됩니다. `toArray(new Object[0])`은 `toArray()`와 기능적으로 동일하다는 것을 주의하세요.\n\n#### `default <T> T[] toArray(IntFunction<T[]> generator)`\n\n- 구현\n  ```java\n  default <T> T[] toArray(IntFunction<T[]> generator) {\n      return toArray(generator.apply(0));\n  }\n  ```\n- 반환된 배열을 할당하기 위한 주어진 제너레이터(generator) 함수를 사용하여, 이 컬렉션의 모든 요소를 포함하는 배열을 반환합니다.\n  이 컬렉션의 반복자(iterator)가 요소의 반환 순서를 보장한다면, 이 메소드는 반드시 같은 순서로 요소들을 반환해야 합니다.\n- Params: 제너레이터(generator) - 원하는 타입과 주어진 길이로 새로운 배열을 생성하는 함수\n- Throws:\n  - `ArrayStoreException` - 이 컬렉션의 어떤 요소의 런타임 타입이 생성된 배열의 런타임 컴포넌트 타입에 할당 가능하지 않은 경우\n  - `NullPointerException` - 제너레이터 함수가 `null`인 경우\n- API Note: 이 메소드는 array-based API와 collection-based API 사이에서 다리 역할을 합니다. 이는 특정 런타임 타입의 배열 생성을 허용합니다. 런타임 타입이 `Object[]`인 배열을 생성하기 위해서는 `toArray()`를 사용하고, 존재하는 배열을 사용하기 위해서는 `toArray(T[])` 사용하세요.\n  문자열만을 포함하는 컬렉션 x가 있다고 합시다. 아래에 주어진 코드는 새로이 할당된 String 배열에 넣는데에 사용될 수 있습니다.\n  ```java\n  String[] y = x.toArray(String[]::new);\n  ```\n- Implementation Requirements: 기본 구현은 0과 함께 제너레이터 함수를 부르고 반환된 배열을 `toArray(T[])`에 전달합니다.\n- Since: 11\n\n## Modification Operations\n\n#### `boolean add(E e);`\n\n- 이 컬렉션이 주어진 요소를 포함하도록 보장합니다. (선택적인 연산) 호출의 결과로 해당 요청이 변하는 경우, `true`를 반환합니다. (만약, 이 컬렉션이 중복을 허용하지 않고 이미 주어진 요소를 포함하는 경우, `false`를 반환합니다.)\n  이 연산을 제공하는 컬렉션들은 이 컬렉션에 어떤 요소들이 추가될지에 대한 제한이 있을 것입니다. 예를 들어, 어떤 컬렉션들은 `null` 요소를 추가하는 것을 거절할 것이고, 다른 컬렉션들은 추가될 요소들의 타입에 제한을 둘 것입니다.\n  컬렉션이 이미 해당 요소를 포함하고 있다는 이유 외에 어떤 다른 이유로 특정 요소를 추가하지 않는 경우, 반드시 Exception을 발생시켜야 합니다. (`false`를 반환하는 것 대신에) 이는 컬렉션이 항상 이 호출 이후에 특정 요소를 포함한다는 불변을 유지합니다.\n- Params: `e` - 이 컬렉션 안에 존재함이 보장된 요소\n- Returns: 이 요청으로 컬렉션이 변경될 때 `true`\n- Throws:\n  - `UnsupportedOperationException` - 이 컬렉션이 add 연산을 지원하지 않는 경우\n  - `ClassCastException` - 주어진 요소의 클래스가 이 컬렉션에 추가됨을 막는 경우\n  - `NullPointerException` - 주어진 요소가 `null`이고 이 컬렉션이 `null` 요소를 허용하지 않는 경우\n  - `IllegalArgumentException` - 요소의 어떤 속성이 이 컬렉션에 추가됨을 막는 경우\n  - `IllegalStateException` - 삽입 제한으로 요소가 이번에 추가될 수 없는 경우\n\n#### `boolean remove(Object o);`\n\n- 만약 주어진 요소가 존재한다면, 이 컬렉션에서 인스턴스 하나를 제거합니다. (선택적인 연산) 더 형식적으로, `Objects.equals(o, e)`를 만족하는 `e`가 이 컬렉션에 하나 이상 포함하는 경우, 이러한 요소 하나를 제거합니다. 만약 이 컬렉션이 주어진 요소를 포함하는 경우, `true`를 반환합니다. (또는 같은 의미로, 이 호출로 이 컬렉션이 변경된 경우)\n- Params: o - 만약 존재한다면 이 컬렉션에서 제거될 요소\n- Returns: 이 호출로 요소가 제거된 경우 `true`\n- Throws:\n  - `ClassCastException` - 주어진 요소의 타입이 이 컬렉션과 맞지 않는 경우\n  - `NullPointerException` - 주어진 요소가 `null`이고 이 컬렉션이 `null` 요소를 허용하지 않는 경우\n  - `UnsupportedOperationException` - 이 컬렉션에서 이 요청을 지원하지 않는 경우\n\n## Bulk Operations\n\n#### `boolean containsAll(Collection<?> c);`\n\n- 주어진 컬렉션의 모든 요소들을 이 컬렉션이 포함한다면 `true`를 반환합니다.\n- Params: `c` - 이 컬렉션 안에 포함 여부를 확인할 컬렉션\n- Returns: 주어진 컬렉션의 모든 요소들이 이 컬렉션이 포함하는 경우 `true`\n- Throws:\n  - `ClassCastException` - 주어진 컬렉션에서 하나 이상의 요소 타입이 이 컬렉션과 맞지 않는 경우\n  - `NullPointerException` - 주어진 컬렉션이 하나 이상의 `null` 요소를 가지고 이 컬렉션이 `null` 요소를 허용하지 않는 경우, 혹은 주어진 컬렉션이 `null`인 경우\n\n#### `boolean addAll(Collection<? extends E> c);`\n\n- 주어진 컬렉션의 모든 요소들을 이 컬렉션에 추가합니다. (선택적인 연산) 연산이 진행되는 동안 주어진 컬렉션이 변경될 때의 이 연산의 행동이 정의되지 않았습니다. (이는 주어진 컬렉션이 이 컬렉션이고 이 컬렉션이 비지 않은 경우, 이 요청의 행위가 정의되지 않음을 뜻합니다.)\n- Params: `c` - 이 컬렉션에 추가될 요소들을 가지고 있는 컬렉션\n- Returns: 이 호출로 이 컬렉션이 변경되면 `true`\n- Throws:\n  - `UnsupporedOperationException` - 이 컬렉션에서 addAll 메소드가 지원되지 않는 경우\n  - `ClassCastException` - 주어진 컬렉션의 요소의 클래스가 이 컬렉션에 추가되는 것을 막는 경우\n  - `NullPointerException` - 주어진 컬렉션이 하나 이상의 `null` 요소를 가지고 이 컬렉션이 `null` 요소를 허용하지 않는 경우, 혹은 주어진 컬렉션이 `null`인 경우\n  - `IllegalArgumentException` - 주어진 컬렉션의 요소의 프로퍼티가 이 컬렉션에 추가되는 것을 막는 경우\n  - `IllegalStateException` - 삽입 제한으로 현재 모든 요소들이 추가될 수 없는 경우\n\n#### `boolean removeAll(Collection<?> c);`\n\n- 이 컬렉션의 요소 중 주어진 컬렉션에도 포함되어 있는 요소들을 제거합니다. (선택적인 연산) 이 호출이 반환된 이후, 이 컬렉션은 주어진 컬렉션과 공통된 요소를 포함하지 않습니다.\n- Params: `c` - 이 컬렉션에서 제거될 요소들을 포함하는 컬렉션\n- Throws:\n  - `UnsupportedOperationException` - 이 컬렉션에서 `removeAll` 메소드가 지원되지 않는 경우\n  - `ClassCastException` - 이 컬렉션에서 하나 이상의 요소 타입이 컬렉션 컬렉션과 맞지 않는 경우\n  - `NullPointerException` - 주어진 컬렉션이 하나 이상의 `null` 요소를 가지고 이 컬렉션이 `null` 요소를 허용하지 않는 경우, 혹은 주어진 컬렉션이 `null`인 경우\n\n#### `default boolean removeIf(Predicate<? super E> filter)`\n\n- 구현\n  ```java\n  default boolean removeIf(Predicate<? super E> filter) {\n      Objects.requireNonNull(filter);\n      boolean removed = false;\n      final Iterator<E> each = iterator();\n      while (each.hasNext()) {\n          if (filter.test(each.next())) {\n              each.remove();\n              removed = true;\n          }\n      }\n      return removed;\n  }\n  ```\n- 주어진 조건을 만족하는 이 컬렉션의 모든 요소를 제거합니다. 반복 중에 발생한 오류나 예외 또는 조건(predicate)에서 발생한 예외는 호출자(caller)에게 전달됩니다.\n- Params: filter - 제거될 요소들이 `true`를 반환하는 조건\n- Returns: 어떤 요소가 제거되면 `true`\n- Throws:\n  - `NullPointerException` - 주어진 filter가 null인 경우\n  - `UnsupportedOperationException` - 이 컬렉션에서 요소들이 제거될 수 없는 경우. 조건에 부합하는 요소가 제거될 수 없거나, 일반적으로 제거가 지원되지 않는 경우 구현체는 이 예외를 발생시킵니다.\n- Implementation Requirements: 기본 구현은 컬렉션의 반복자를 사용해서 컬렉션의 모든 요소를 순회합니다. 조건에 부합하는 요소는 `Iterator.remove()`를 이용하여 제거됩니다. 만약 컬렉션의 반복자가 제거를 지원하지 않는 경우, 조건에 부합하는 첫 번째 요소에서 `UnsupportedOperationException`을 발생시킵니다.\n- Since: 1.8\n\n#### `boolean retainAll(Collection<?> c);`\n\n- 주어진 컬렉션에 포함된 요소만 이 컬렉션에 유지합니다. (선택적인 연산) 다시 말해, 주어진 컬렉션에 포함되지 않는 모든 요소들은 이 컬렉션에서 제거합니다.\n- Params: `c` - 이 컬렉션에서 유지할 요소들을 포함하는 컬렉션\n- Throws:\n  - `UnsupportedOperationException` - 이 컬렉션에서 `retainAll` 메소드를 지원하지 않는 경우\n  - `ClassCastException` - 이 컬렉션에서 하나 이상의 요소 타입이 컬렉션 컬렉션과 맞지 않는 경우\n  - `NullPointerException` - 주어진 컬렉션이 하나 이상의 `null` 요소를 가지고 이 컬렉션이 `null` 요소를 허용하지 않는 경우, 혹은 주어진 컬렉션이 `null`인 경우\n\n#### `void clear();`\n\n- 이 컬렉션에서 모든 요소들을 제거합니다. (선택적인 연산) 이 호출이 반환된 이후, 컬렉션은 비게 됩니다.\n- Throws:\n  - `UnsupportedOperationException` - 이 컬렉션에서 `clear` 메소드를 지원하지 않는 경우\n\n## Comparison and hashing\n\n#### `boolean equals(Object o);`\n\n- 이 컬렉션과 주어진 객체의 동등성을 비교합니다.\n  Collection 인터페이스는 `Object.equals`에 대한 일반 계약에 대한 규정을 추가하지 않지만, Collection 인터페이스를 직접 구현하는 프로그래머(다시 말해, Set 또는 List가 아닌 Collection 인터페이스를 구현하는 클래스를 만드는 경우)는 `Object.equals`를 재정의하기로 했다면 주의를 기울여야 합니다. 이렇게 할 필요는 없으며, 가장 간단한 방법은 `Object`의 구현을 사용하는 것입니다. 그러나 구현하는 사람은 기본 \"참조 비교\" 대신 \"값 비교\"를 구현하기를 원할 수 있습니다. (List와 Set 인터페이스는 이러한 값 비교를 강제합니다.)\n  `Object.equals` 메소드의 일반 명세는 `equals`가 대칭적이어야 한다고 명시합니다. (다시 말해, `a.equals(b)`이면 `b.equals(a)`여야 합니다(_iff_)) `List.equals`와 `Set.equals`의 명세에서는 리스트은 다른 목록과만 동일하고, 집합은 다른 집합과만 동일하다고 명시합니다. 따라서 List 또는 Set 인터페이스를 구현하지 않는 컬렉션 클래스에 대한 사용자 정의 `equals` 메소드는 이 컬렉션이 어떤 목록 또는 집합과 비교될 때 항상 `false`를 반환해야 합니다. (같은 논리에 따라, Set과 List 인터페이스를 동시에 올바르게 구현하는 클래스를 작성하는 것은 불가능합니다.)\n- Params: `o` - 이 컬렉션과 동등성이 비교될 객체\n- Returns: 해당 객체와 주어진 객체가 같은 경우 `true`\n\n#### `int hashCode();`\n\n- 이 컬렉션의 해시 코드 값을 반환합니다. Collection 인터페이스는 `Object.hashCode` 메소드의 일반 명세에 대한 규정을 추가하지 않지만, 프로그래머는 `Object.equals` 메소드를 재정의하는 모든 클래스는 `Object.hashCode` 메소드도 재정의해야 하며 `Object.hashCode` 메소드의 일반 명세를 만족시키기 위해 `c1.equals(c2)`이라면 `c1.hashCode() == c2.hashCode()`임을 고려해야 합니다.\n- Returns: 이 컬렉션의 해시 코드 값\n\n#### `default Spliterator<E> spliterator()`\n\n- 구현\n  ```java\n  @Override\n  default Spliterator<E> spliterator() {\n      return Spliterators.spliterator(this, 0);\n  }\n  ```\n- 이 컬렉션의 요소들을 순회하는 `Spliterator`를 생성합니다. 구현체는 Spliterator에 의해 보고된 특정 값들을 문서화해야 합니다. Spliterator가 `Spliterator.SIZED`를 보고하고 이 컬렉션이 아무런 요소를 포함하지 않는 경우, 이런 특정 값들은 보고될 필요가 없습니다.\n  더 효율적인 Spliterator를 반환할 수 있는 하위 클래스에서는 기본 구현을 재정의(override)해야 합니다. `stream()`과 `parallelStream()` 메소드의 예상된 지연 동작(expected laziness behavior)을 유지하기 위해서 Spliterator는 `IMMUTABLE` 또는 `CONCURRENT` 특성을 가지거나, 늦은 바인딩(late-binding)이어야 합니다. 이 방법들이 불가능한 경우, 재정의된 클래스는 Spliterator의 바인딩과 구조적인 간섭의 문서화된 정책을 설명하고, `stream()` 및 `parallelStream()` 메소드를 재정의하여 Spliterator의 `Supplier`를 사용하는 스트림을 아래와 같이 생성해야 합니다.\n\n  ```java\n    Stream<E> s = StreamSupport.stream(() -> spliterator(), spliteratorCharacteristics)\n  ```\n\n  이러한 요구 사항은 `stream()` 및 `parallelStream()` 메소드에 의해 생성된 스트림이 최종 스트림 작업의 시작 시점에 컬렉션의 내용을 반영하도록 보장합니다.\n\n- Returns: 이 컬렉션을 순회하는 `Spliterator`\n- Implementation Requirements: 기본 구현체는 이 컬렉션의 반복자에서 late-binding Spliterator를 생성합니다. Spliterator는 컬렉션의 iterator의 _fail-fast_ 속성을 상속합니다.\n  생성된 Spliterator는 `Spliterator.SIZED`를 보고합니다.\n- Implementation Note: 생성된 Spliterator는 추가적으로 `Spliterator.SUBSIZED`를 보고합니다. Spliterator가 어떤 요소도 포함하지 않는 경우에는 `SIZED` 및 `SUBSIZED`를 포함한 추가적인 특정 값의 보고가 클라이언트가 계산을 제어, 특화 또는 단순화하는 데 도움이 되지 않습니다. 그러나 이것은 빈 컬렉션의 경우 불변(immutable)하고 빈 Spliterator 인스턴스(`Spliterators.emptySpliterator()` 참조)의 공유 사용을 가능하게 하고, 클라이언트가 그러한 Spliterator가 어떤 요소도 포함하지 않는지 여부를 결정할 수 있도록 합니다.\n- Since: 1.8\n\n#### `default Stream<E> stream()`\n\n- 구현\n  ```java\n  default Stream<E> stream() {\n      return StreamSupport.stream(spliterator(), false);\n  }\n  ```\n- 이 컬렉션을 소스로 하는 연속적인 스트림을 반환합니다.\n  이 메소드는 `spliterator()` 메소드가 `IMMUTABLE`, `CONCURRENT`이거나 late-binding인 Spliterator를 반환할 수 없는 경우 재정의(override)되어야 합니다. (`spliterator()` 참조)\n- Returns: 이 컬렉션의 요소들을 순회하는 연속적인 Stream\n- Implementation Requirements: 기본 구현체는 이 컬렉션의 `Spliterator`에서 연속적인 Stream을 생성합니다.\n- Since: 1.8\n\n#### `default Stream<E> parallelStream()`\n\n- 구현\n  ```java\n  default Stream<E> parallelStream() {\n      return StreamSupport.stream(spliterator(), true);\n  }\n  ```\n- 이 컬렉션을 소스로 하는 가능한 병렬 스트림을 반환합니다. 이 메소드가 연속적인 스트림을 반환하는 것이 허용됩니다.\n  이 메소드는 `spliterator()` 메소드가 `IMMUTABLE`, `CONCURRENT`이거나 late-binding인 Spliterator를 반환할 수 없는 경우 재정의(override)되어야 합니다. (`spliterator()` 참조)\n- Returns: 이 컬렉션의 요소들을 순회하는 가능한 병렬 스트림\n- Implementation Requirements: 기본 구현체는 이 컬렉션의 `Spliterator`에서 병렬 스트림을 생성합니다.\n- Since: 1.8\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}